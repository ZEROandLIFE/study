在 Vue 3 中，watch 用于监听响应式数据（如 ref、reactive、computed 等）的变化，并在数据变化时执行回调函数。它比 Vue 2 的 watch 更灵活，支持监听单个数据源、多个数据源、甚至 getter 函数。以下是详细用法：

1. 基本用法
(1) 监听 ref
ts
import { ref, watch } from "vue";

const count = ref(0);

watch(count, (newValue, oldValue) => {
  console.log(`count 变化了：${oldValue} -> ${newValue}`);
});
(2) 监听 reactive 的属性
ts
import { reactive, watch } from "vue";

const user = reactive({ name: "张三", age: 20 });

// 监听单个属性
watch(
  () => user.age,
  (newAge, oldAge) => {
    console.log(`age 变化了：${oldAge} -> ${newAge}`);
  }
);

// 监听整个对象（需 deep: true）
watch(
  () => user,
  (newUser, oldUser) => {
    console.log("user 变化了", newUser);
  },
  { deep: true } // 深度监听
);
2. 监听多个数据源
可以传入一个数组，同时监听多个数据：

ts
import { ref, watch } from "vue";

const count = ref(0);
const name = ref("张三");

watch([count, name], ([newCount, newName], [oldCount, oldName]) => {
  console.log(`count: ${oldCount} -> ${newCount}`);
  console.log(`name: ${oldName} -> ${newName}`);
});
3. 立即触发回调
默认情况下，watch 只在数据变化时触发。如果想在初始化时立即执行一次回调，可以设置 immediate: true：

ts
watch(
  count,
  (newValue, oldValue) => {
    console.log(`count 变化了：${oldValue} -> ${newValue}`);
  },
  { immediate: true } // 立即执行一次
);
4. 深度监听
对于 reactive 对象或嵌套数据，默认情况下 watch 不会深度监听（除非监听的是整个对象）。如果需要深度监听，可以设置 deep: true：

ts
const user = reactive({ info: { score: 90 } });

watch(
  () => user.info,
  (newInfo, oldInfo) => {
    console.log("user.info 变化了", newInfo);
  },
  { deep: true } // 深度监听
);
5. 监听 getter 函数
可以监听一个计算属性（getter 函数）的返回值：

ts
const user = reactive({ firstName: "三", lastName: "张" });

watch(
  () => `${user.lastName} ${user.firstName}`, // 监听计算后的全名
  (fullName) => {
    console.log("全名变化了:", fullName);
  }
);
6. 停止监听
watch 返回一个停止函数，可以手动停止监听：

ts
const stop = watch(count, (newVal) => {
  console.log("count:", newVal);
});

// 停止监听
stop();
7. 完整示例
ts
<template>
  <div>
    <p>Count: {{ count }}</p>
    <button @click="count++">增加</button>
    <p>Name: {{ user.name }}</p>
    <input v-model="user.name" placeholder="修改名字" />
  </div>
</template>

<script setup lang="ts">
import { ref, reactive, watch } from "vue";

const count = ref(0);
const user = reactive({ name: "张三" });

// 监听 ref
watch(count, (newVal, oldVal) => {
  console.log(`count 从 ${oldVal} 变为 ${newVal}`);
});

// 监听 reactive 的属性
watch(
  () => user.name,
  (newName, oldName) => {
    console.log(`name 从 ${oldName} 变为 ${newName}`);
  }
);

// 监听多个数据
watch(
  [count, () => user.name],
  ([newCount, newName], [oldCount, oldName]) => {
    console.log(`count: ${oldCount} -> ${newCount}, name: ${oldName} -> ${newName}`);
  }
);
</script>
8. watch vs watchEffect
特性	watch	watchEffect
监听目标	明确指定数据源	自动追踪回调内的响应式依赖
执行时机	默认懒执行（可配置 immediate）	立即执行
访问旧值	可获取 oldValue	无法直接获取旧值
适用场景	需要精确控制监听目标时	副作用逻辑较简单时
watchEffect 示例：

ts
import { ref, watchEffect } from "vue";

const count = ref(0);

watchEffect(() => {
  console.log("count 变化了:", count.value); // 自动追踪 count 的依赖
});
总结
需求	推荐方式
监听 ref	watch(ref, callback)
监听 reactive 的属性	watch(() => obj.prop, callback)
监听整个 reactive 对象	watch(() => obj, callback, { deep: true })
监听多个数据	watch([ref1, ref2], callback)
立即执行回调	watch(data, callback, { immediate: true })
深度监听	watch(data, callback, { deep: true })
停止监听	const stop = watch(...); stop();