# Vue 3 èŠ‚æµå®Œå…¨æŒ‡å— âš¡

## ğŸ¯ èŠ‚æµåœ¨ Vue 3 ä¸­çš„æ ¸å¿ƒæ¦‚å¿µ

**èŠ‚æµï¼ˆThrottleï¼‰**ï¼šé«˜é¢‘äº‹ä»¶è§¦å‘æ—¶ï¼Œ**å›ºå®šé¢‘ç‡æ‰§è¡Œ**ï¼Œç¨€é‡Šæ‰§è¡Œé¢‘ç‡ã€‚

ä¸é˜²æŠ–çš„åŒºåˆ«ï¼š
- **é˜²æŠ–**ï¼š`|--x--x----x---x------x---|` â†’ æ‰§è¡Œæœ€å1æ¬¡
- **èŠ‚æµ**ï¼š`|--x--x----x---x------x---|` â†’ æ¯Nç§’æ‰§è¡Œ1æ¬¡

## ğŸ”§ 6 ç§ Vue 3 èŠ‚æµå®ç°æ–¹å¼

### 1. **Composition API åŸç”Ÿå®ç°**
```javascript
// useThrottle.js
import { ref, onUnmounted } from 'vue'

// 1. æ—¶é—´æˆ³å®ç°ï¼ˆç«‹å³æ‰§è¡Œï¼‰
export function useThrottle(fn, delay = 300) {
  let lastTime = 0
  const throttledFn = (...args) => {
    const now = Date.now()
    if (now - lastTime >= delay) {
      fn(...args)
      lastTime = now
    }
  }
  
  return throttledFn
}

// 2. å®šæ—¶å™¨å®ç°ï¼ˆå»¶è¿Ÿæ‰§è¡Œï¼‰
export function useThrottleTimer(fn, delay = 300) {
  let timer = null
  const throttledFn = (...args) => {
    if (!timer) {
      timer = setTimeout(() => {
        fn(...args)
        timer = null
      }, delay)
    }
  }
  
  const cancel = () => {
    if (timer) {
      clearTimeout(timer)
      timer = null
    }
  }
  
  onUnmounted(cancel)
  
  return { throttledFn, cancel }
}

// 3. ç»„åˆå®ç°ï¼ˆé¦–å°¾éƒ½æ‰§è¡Œï¼‰
export function useThrottleAdvanced(fn, delay = 300) {
  let timer = null
  let lastTime = 0
  
  const throttledFn = (...args) => {
    const now = Date.now()
    const remaining = delay - (now - lastTime)
    
    if (remaining <= 0) {
      // é¦–æ¬¡æˆ–è¶…è¿‡é—´éš”ï¼Œç«‹å³æ‰§è¡Œ
      if (timer) {
        clearTimeout(timer)
        timer = null
      }
      fn(...args)
      lastTime = now
    } else if (!timer) {
      // è®¾ç½®å»¶è¿Ÿæ‰§è¡Œï¼Œç¡®ä¿æœ€åä¸€æ¬¡è§¦å‘è¢«æ‰§è¡Œ
      timer = setTimeout(() => {
        fn(...args)
        lastTime = Date.now()
        timer = null
      }, remaining)
    }
  }
  
  const cancel = () => {
    if (timer) {
      clearTimeout(timer)
      timer = null
    }
    lastTime = 0
  }
  
  onUnmounted(cancel)
  
  return { throttledFn, cancel }
}
```

### 2. **ç»„ä»¶å†…ç›´æ¥ä½¿ç”¨**
```vue
<script setup>
import { ref } from 'vue'

// 1. æ—¶é—´æˆ³èŠ‚æµï¼ˆç«‹å³æ‰§è¡Œï¼‰
const throttle = (fn, delay = 300) => {
  let lastTime = 0
  return (...args) => {
    const now = Date.now()
    if (now - lastTime >= delay) {
      fn.apply(this, args)
      lastTime = now
    }
  }
}

// 2. å®šæ—¶å™¨èŠ‚æµï¼ˆå»¶è¿Ÿæ‰§è¡Œï¼‰
const throttleTimer = (fn, delay = 300) => {
  let timer = null
  return (...args) => {
    if (!timer) {
      timer = setTimeout(() => {
        fn.apply(this, args)
        timer = null
      }, delay)
    }
  }
}

// 3. å¯é…ç½®çš„èŠ‚æµ
const createThrottle = (fn, delay = 300, options = {}) => {
  const { leading = true, trailing = true } = options
  let timer = null
  let lastTime = 0
  
  return (...args) => {
    const now = Date.now()
    
    // å¦‚æœä¸ç«‹å³æ‰§è¡Œï¼Œé‡ç½®ä¸Šæ¬¡æ‰§è¡Œæ—¶é—´
    if (!leading && lastTime === 0) {
      lastTime = now
    }
    
    const remaining = delay - (now - lastTime)
    
    if (remaining <= 0) {
      if (timer) {
        clearTimeout(timer)
        timer = null
      }
      if (leading) {
        fn.apply(this, args)
      }
      lastTime = now
    } else if (trailing && !timer) {
      timer = setTimeout(() => {
        fn.apply(this, args)
        lastTime = Date.now()
        timer = null
      }, remaining)
    }
  }
}

// ä½¿ç”¨ç¤ºä¾‹
const handleScroll = throttle((event) => {
  console.log('æ»šåŠ¨ä½ç½®:', event.target.scrollTop)
}, 100)

const handleMouseMove = throttleTimer((event) => {
  console.log('é¼ æ ‡ä½ç½®:', event.clientX, event.clientY)
}, 50)
</script>
```

### 3. **è‡ªå®šä¹‰æŒ‡ä»¤å®ç°**
```javascript
// directives/throttle.js
export const vThrottle = {
  mounted(el, binding) {
    const { value: fn, arg: delay = 300, modifiers } = binding
    
    let timer = null
    let lastTime = 0
    
    // æ ¹æ®ä¿®é¥°ç¬¦é€‰æ‹©èŠ‚æµç­–ç•¥
    const strategy = modifiers.immediate ? 'leading' : 
                    modifiers.trailing ? 'trailing' : 'both'
    
    const handler = (event) => {
      const now = Date.now()
      
      if (strategy === 'leading' || strategy === 'both') {
        // ç«‹å³æ‰§è¡Œç­–ç•¥
        if (now - lastTime >= delay) {
          fn(event)
          lastTime = now
        }
      }
      
      if (strategy === 'trailing' || strategy === 'both') {
        // å»¶è¿Ÿæ‰§è¡Œç­–ç•¥
        if (!timer) {
          timer = setTimeout(() => {
            fn(event)
            lastTime = Date.now()
            timer = null
          }, delay - (now - lastTime))
        }
      }
    }
    
    // å­˜å‚¨ handler ç”¨äºæ¸…ç†
    el._throttleHandler = handler
    
    // ç›‘å¬äº‹ä»¶
    const events = modifiers.scroll ? ['scroll'] :
                   modifiers.mousemove ? ['mousemove'] :
                   modifiers.resize ? ['resize'] : ['click']
    
    events.forEach(eventName => {
      el.addEventListener(eventName, handler)
    })
  },
  unmounted(el) {
    if (el._throttleHandler) {
      // æ¸…ç†äº‹ä»¶ç›‘å¬å™¨
      const events = ['scroll', 'mousemove', 'resize', 'click']
      events.forEach(eventName => {
        el.removeEventListener(eventName, el._throttleHandler)
      })
    }
  }
}

// å…¨å±€æ³¨å†Œ
import { createApp } from 'vue'
const app = createApp(App)
app.directive('throttle', vThrottle)
```

```vue
<!-- ä½¿ç”¨è‡ªå®šä¹‰æŒ‡ä»¤ -->
<template>
  <!-- æ»šåŠ¨èŠ‚æµï¼ˆç«‹å³æ‰§è¡Œï¼‰ -->
  <div 
    v-throttle.scroll:100="handleScroll"
    class="scroll-container"
  >
    æ»šåŠ¨å†…å®¹...
  </div>
  
  <!-- é¼ æ ‡ç§»åŠ¨èŠ‚æµï¼ˆå»¶è¿Ÿæ‰§è¡Œï¼‰ -->
  <div 
    v-throttle.mousemove.trailing:50="handleMouseMove"
    class="interactive-area"
  >
    é¼ æ ‡ç§»åŠ¨åŒºåŸŸ
  </div>
  
  <!-- æŒ‰é’®ç‚¹å‡»èŠ‚æµï¼ˆé˜²æ­¢å¿«é€Ÿç‚¹å‡»ï¼‰ -->
  <button v-throttle.click:1000="handleClick">
    èŠ‚æµæŒ‰é’®
  </button>
  
  <!-- çª—å£resizeèŠ‚æµ -->
  <div v-throttle.resize:200="handleResize">
    å“åº”å¼å†…å®¹
  </div>
</template>
```

### 4. **VueUse çš„èŠ‚æµå‡½æ•°**
```vue
<script setup>
import { ref } from 'vue'
import { useThrottleFn, throttledWatch, useThrottle } from '@vueuse/core'

// 1. useThrottleFn - æœ€å¸¸ç”¨
const mousePosition = ref({ x: 0, y: 0 })

const updateMousePosition = useThrottleFn((event) => {
  mousePosition.value = {
    x: event.clientX,
    y: event.clientY
  }
}, 50)

// 2. throttledWatch - èŠ‚æµç›‘å¬
const scrollPosition = ref(0)

throttledWatch(
  scrollPosition,
  (newPos) => {
    console.log('æ»šåŠ¨ä½ç½®:', newPos)
    // æ‰§è¡Œæ»šåŠ¨ç›¸å…³é€»è¾‘
  },
  { throttle: 100 }
)

// 3. useThrottle - èŠ‚æµçš„å“åº”å¼å€¼
const throttledValue = useThrottle(searchKeyword, 500)

// 4. å¸¦æ›´å¤šé…ç½®
const throttledFn = useThrottleFn(
  (value) => {
    console.log('èŠ‚æµæ‰§è¡Œ:', value)
  },
  300,
  { trailing: true, leading: false }
)
</script>

<template>
  <div @mousemove="updateMousePosition">
    é¼ æ ‡ä½ç½®: {{ mousePosition.x }}, {{ mousePosition.y }}
  </div>
  
  <div @scroll="(e) => scrollPosition = e.target.scrollTop">
    æ»šåŠ¨å®¹å™¨
  </div>
</template>
```

### 5. **é«˜çº§èŠ‚æµ Hook**
```javascript
// useAdvancedThrottle.js
import { onUnmounted } from 'vue'

export function useAdvancedThrottle(options = {}) {
  const {
    delay = 300,
    leading = true,   // æ˜¯å¦ç«‹å³æ‰§è¡Œ
    trailing = true,  // æ˜¯å¦å»¶è¿Ÿæ‰§è¡Œ
    maxWait = null    // æœ€å¤§ç­‰å¾…æ—¶é—´
  } = options

  let timer = null
  let lastTime = 0
  let lastArgs = null
  let lastThis = null

  const invokeFunc = (time) => {
    const args = lastArgs
    const thisArg = lastThis
    
    lastArgs = lastThis = null
    lastTime = time
    
    return fn.apply(thisArg, args)
  }

  const throttled = function(...args) {
    const now = Date.now()
    
    lastArgs = args
    lastThis = this
    
    if (!lastTime && !leading) {
      lastTime = now
    }
    
    const remaining = delay - (now - lastTime)
    
    // è¶…è¿‡é—´éš”æˆ–é¦–æ¬¡æ‰§è¡Œ
    if (remaining <= 0 || remaining > delay) {
      if (timer) {
        clearTimeout(timer)
        timer = null
      }
      if (leading) {
        return invokeFunc(now)
      }
      lastTime = now
    } else if (trailing && !timer) {
      // è®¾ç½®å»¶è¿Ÿæ‰§è¡Œ
      timer = setTimeout(() => {
        const time = Date.now()
        lastTime = leading ? time : 0
        timer = null
        invokeFunc(time)
      }, remaining)
    }
    
    // æœ€å¤§ç­‰å¾…æ—¶é—´ä¿æŠ¤
    if (maxWait !== null && !timer) {
      timer = setTimeout(() => {
        timer = null
        if (lastArgs) {
          invokeFunc(Date.now())
        }
      }, maxWait)
    }
  }

  const cancel = () => {
    if (timer) {
      clearTimeout(timer)
      timer = null
    }
    lastTime = 0
    lastArgs = lastThis = null
  }

  const flush = () => {
    return timer === null ? undefined : invokeFunc(Date.now())
  }

  onUnmounted(cancel)

  return {
    throttled,
    cancel,
    flush
  }
}
```

### 6. **å“åº”å¼èŠ‚æµ Ref**
```vue
<script setup>
import { ref, watch } from 'vue'

// èŠ‚æµçš„å“åº”å¼ ref
function useThrottledRef(initialValue, delay = 300) {
  const value = ref(initialValue)
  let timer = null
  let lastUpdate = 0
  
  const setValue = (newValue) => {
    const now = Date.now()
    
    // ç«‹å³æ›´æ–°å€¼
    value.value = newValue
    
    // èŠ‚æµè§¦å‘å‰¯ä½œç”¨
    if (now - lastUpdate >= delay) {
      lastUpdate = now
      // å¯ä»¥åœ¨è¿™é‡Œè§¦å‘å…¶ä»–é€»è¾‘
    } else if (!timer) {
      timer = setTimeout(() => {
        lastUpdate = Date.now()
        timer = null
      }, delay - (now - lastUpdate))
    }
  }
  
  return {
    value,
    setValue
  }
}

// ä½¿ç”¨
const throttledInput = useThrottledRef('', 500)

// ç›‘å¬èŠ‚æµåçš„å˜åŒ–
watch(
  () => throttledInput.value,
  (newVal) => {
    console.log('èŠ‚æµåçš„å€¼:', newVal)
    // è¿™é‡Œä¼šä»¥500msçš„é¢‘ç‡è§¦å‘
  }
)
</script>

<template>
  <input 
    :value="throttledInput.value"
    @input="(e) => throttledInput.setValue(e.target.value)"
  />
</template>
```

## ğŸ¨ å®é™…åº”ç”¨åœºæ™¯

### **åœºæ™¯1ï¼šæ»šåŠ¨äº‹ä»¶èŠ‚æµ**
```vue
<template>
  <div class="scroll-container" ref="scrollContainer">
    <!-- é•¿åˆ—è¡¨å†…å®¹ -->
    <div 
      v-for="item in visibleItems" 
      :key="item.id"
      class="list-item"
    >
      {{ item.content }}
    </div>
    
    <!-- æ»šåŠ¨æŒ‡ç¤ºå™¨ -->
    <div class="scroll-indicator" :style="indicatorStyle">
      æ»šåŠ¨ä½ç½®: {{ scrollPosition }}px
    </div>
    
    <!-- è™šæ‹Ÿæ»šåŠ¨åŠ è½½ -->
    <div 
      v-if="shouldLoadMore" 
      class="load-more-trigger"
      @click="loadMore"
    >
      åŠ è½½æ›´å¤š
    </div>
  </div>
</template>

<script setup>
import { ref, onMounted, onUnmounted, computed } from 'vue'
import { useThrottleFn } from '@vueuse/core'

const scrollContainer = ref(null)
const scrollPosition = ref(0)
const items = ref([/* å¤§æ•°æ®æ•°ç»„ */])
const page = ref(1)
const loading = ref(false)

// è®¡ç®—å¯è§é¡¹ï¼ˆè™šæ‹Ÿæ»šåŠ¨ï¼‰
const visibleItems = computed(() => {
  const start = Math.floor(scrollPosition.value / 50)
  return items.value.slice(start, start + 20)
})

// æ»šåŠ¨ä½ç½®æŒ‡ç¤ºå™¨æ ·å¼
const indicatorStyle = computed(() => ({
  transform: `translateY(${scrollPosition.value}px)`,
  opacity: Math.min(scrollPosition.value / 100, 1)
}))

// èŠ‚æµæ»šåŠ¨å¤„ç†
const handleScroll = useThrottleFn(() => {
  if (!scrollContainer.value) return
  
  const { scrollTop, scrollHeight, clientHeight } = scrollContainer.value
  scrollPosition.value = scrollTop
  
  // æ£€æŸ¥æ˜¯å¦éœ€è¦åŠ è½½æ›´å¤š
  if (scrollTop + clientHeight >= scrollHeight - 100) {
    loadMore()
  }
  
  // æ›´æ–°å…¶ä»–ä¾èµ–æ»šåŠ¨ä½ç½®çš„é€»è¾‘
  updateParallax()
  updateStickyHeaders()
}, 50)

// åŠ è½½æ›´å¤šæ•°æ®
const loadMore = async () => {
  if (loading.value) return
  
  loading.value = true
  try {
    const newItems = await fetchMoreData(page.value)
    items.value.push(...newItems)
    page.value++
  } finally {
    loading.value = false
  }
}

// æ˜¯å¦åº”è¯¥æ˜¾ç¤ºåŠ è½½æ›´å¤š
const shouldLoadMore = computed(() => {
  return !loading.value && items.value.length < 1000
})

// å…¶ä»–æ»šåŠ¨ç›¸å…³æ•ˆæœ
const updateParallax = () => {
  // è§†å·®æ•ˆæœæ›´æ–°
}

const updateStickyHeaders = () => {
  // ç²˜æ€§å¤´éƒ¨æ›´æ–°
}

onMounted(() => {
  if (scrollContainer.value) {
    scrollContainer.value.addEventListener('scroll', handleScroll)
  }
})

onUnmounted(() => {
  if (scrollContainer.value) {
    scrollContainer.value.removeEventListener('scroll', handleScroll)
  }
})
</script>

<style scoped>
.scroll-container {
  height: 500px;
  overflow-y: auto;
  position: relative;
}

.list-item {
  height: 50px;
  border-bottom: 1px solid #eee;
  padding: 10px;
}

.scroll-indicator {
  position: fixed;
  top: 20px;
  right: 20px;
  background: rgba(0,0,0,0.8);
  color: white;
  padding: 10px;
  border-radius: 5px;
  transition: opacity 0.3s;
}

.load-more-trigger {
  text-align: center;
  padding: 20px;
  background: #f5f5f5;
  cursor: pointer;
}
</style>
```

### **åœºæ™¯2ï¼šé¼ æ ‡è·Ÿéš/æ‹–æ‹½èŠ‚æµ**
```vue
<template>
  <div class="interactive-container">
    <!-- é¼ æ ‡è·Ÿéšæ•ˆæœ -->
    <div 
      class="follow-area"
      @mousemove="handleMouseMove"
    >
      <div 
        class="follower" 
        :style="followerStyle"
      >
        ğŸ¯
      </div>
      
      <!-- ç²’å­æ•ˆæœ -->
      <div 
        v-for="(particle, index) in particles" 
        :key="index"
        class="particle"
        :style="particle.style"
      >
      </div>
    </div>
    
    <!-- æ‹–æ‹½å…ƒç´  -->
    <div 
      class="draggable"
      :style="draggableStyle"
      @mousedown="startDrag"
    >
      æ‹–æ‹½æˆ‘
    </div>
    
    <!-- å®æ—¶åæ ‡æ˜¾ç¤º -->
    <div class="coordinates">
      åæ ‡: ({{ mouse.x }}, {{ mouse.y }})
      æ‹–æ‹½: ({{ dragPosition.x }}, {{ dragPosition.y }})
    </div>
  </div>
</template>

<script setup>
import { ref, reactive, onMounted, onUnmounted } from 'vue'
import { useThrottleFn } from '@vueuse/core'

const mouse = reactive({ x: 0, y: 0 })
const followerStyle = ref({})
const particles = ref([])
const isDragging = ref(false)
const dragPosition = reactive({ x: 100, y: 100 })

// èŠ‚æµé¼ æ ‡ç§»åŠ¨å¤„ç†
const handleMouseMove = useThrottleFn((event) => {
  const rect = event.currentTarget.getBoundingClientRect()
  mouse.x = event.clientX - rect.left
  mouse.y = event.clientY - rect.top
  
  // æ›´æ–°è·Ÿéšå™¨ä½ç½®
  followerStyle.value = {
    transform: `translate(${mouse.x - 20}px, ${mouse.y - 20}px)`,
    transition: 'transform 0.1s ease'
  }
  
  // åˆ›å»ºç²’å­æ•ˆæœï¼ˆèŠ‚æµæ§åˆ¶é¢‘ç‡ï¼‰
  if (Math.random() > 0.7) {
    createParticle(mouse.x, mouse.y)
  }
}, 16) // çº¦60fps

// åˆ›å»ºç²’å­
const createParticle = (x, y) => {
  const particle = {
    x,
    y,
    size: Math.random() * 10 + 5,
    speedX: (Math.random() - 0.5) * 4,
    speedY: (Math.random() - 0.5) * 4,
    opacity: 1,
    style: {}
  }
  
  particles.value.push(particle)
  
  // ç²’å­åŠ¨ç”»
  const animate = () => {
    particle.x += particle.speedX
    particle.y += particle.speedY
    particle.opacity -= 0.02
    
    particle.style = {
      transform: `translate(${particle.x}px, ${particle.y}px)`,
      opacity: particle.opacity,
      width: `${particle.size}px`,
      height: `${particle.size}px`
    }
    
    if (particle.opacity > 0) {
      requestAnimationFrame(animate)
    } else {
      particles.value = particles.value.filter(p => p !== particle)
    }
  }
  
  animate()
}

// æ‹–æ‹½åŠŸèƒ½ï¼ˆä½¿ç”¨æ—¶é—´æˆ³èŠ‚æµï¼‰
let dragLastTime = 0
const dragThrottle = (fn, delay) => {
  return (...args) => {
    const now = Date.now()
    if (now - dragLastTime >= delay) {
      fn(...args)
      dragLastTime = now
    }
  }
}

const startDrag = (event) => {
  isDragging.value = true
  const startX = event.clientX - dragPosition.x
  const startY = event.clientY - dragPosition.y
  
  const handleDrag = dragThrottle((moveEvent) => {
    dragPosition.x = moveEvent.clientX - startX
    dragPosition.y = moveEvent.clientY - startY
  }, 16)
  
  const handleMouseUp = () => {
    isDragging.value = false
    document.removeEventListener('mousemove', handleDrag)
    document.removeEventListener('mouseup', handleMouseUp)
  }
  
  document.addEventListener('mousemove', handleDrag)
  document.addEventListener('mouseup', handleMouseUp)
}

// æ‹–æ‹½å…ƒç´ æ ·å¼
const draggableStyle = computed(() => ({
  transform: `translate(${dragPosition.x}px, ${dragPosition.y}px)`,
  cursor: isDragging.value ? 'grabbing' : 'grab'
}))

// æ¸…ç†
onUnmounted(() => {
  particles.value = []
})
</script>

<style scoped>
.interactive-container {
  position: relative;
  height: 500px;
  background: #f0f0f0;
  overflow: hidden;
}

.follow-area {
  width: 100%;
  height: 400px;
  position: relative;
  border-bottom: 1px solid #ddd;
}

.follower {
  position: absolute;
  width: 40px;
  height: 40px;
  background: #3498db;
  border-radius: 50%;
  display: flex;
  align-items: center;
  justify-content: center;
  color: white;
  font-size: 20px;
  pointer-events: none;
}

.particle {
  position: absolute;
  background: #e74c3c;
  border-radius: 50%;
  pointer-events: none;
}

.draggable {
  position: absolute;
  width: 100px;
  height: 100px;
  background: #2ecc71;
  color: white;
  display: flex;
  align-items: center;
  justify-content: center;
  border-radius: 10px;
  user-select: none;
}

.coordinates {
  position: absolute;
  bottom: 0;
  left: 0;
  right: 0;
  padding: 10px;
  background: rgba(0,0,0,0.8);
  color: white;
  font-family: monospace;
}
</style>
```

### **åœºæ™¯3ï¼šæ¸¸æˆæ§åˆ¶/åŠ¨ç”»å¸§èŠ‚æµ**
```vue
<template>
  <div class="game-container">
    <!-- æ¸¸æˆåŒºåŸŸ -->
    <canvas ref="canvas" width="800" height="500"></canvas>
    
    <!-- æ¸¸æˆæ§åˆ¶ -->
    <div class="game-controls">
      <button 
        v-throttle.click:100="fireBullet"
        class="fire-btn"
      >
        å°„å‡»
      </button>
      
      <button 
        v-throttle.click:500="useSpecialSkill"
        class="skill-btn"
      >
        ç‰¹æ®ŠæŠ€èƒ½
      </button>
      
      <!-- é”®ç›˜æ§åˆ¶ -->
      <div class="keyboard-hint">
        æ–¹å‘é”®ç§»åŠ¨ï¼Œç©ºæ ¼å°„å‡»
      </div>
    </div>
    
    <!-- æ¸¸æˆçŠ¶æ€ -->
    <div class="game-stats">
      <div>å¸§ç‡: {{ fps }} FPS</div>
      <div>å­å¼¹: {{ bullets.length }}</div>
      <div>åˆ†æ•°: {{ score }}</div>
    </div>
  </div>
</template>

<script setup>
import { ref, onMounted, onUnmounted } from 'vue'
import { useThrottleFn } from '@vueuse/core'

const canvas = ref(null)
const ctx = ref(null)
const player = reactive({ x: 400, y: 400, speed: 5 })
const bullets = ref([])
const enemies = ref([])
const score = ref(0)
const fps = ref(60)

// ä½¿ç”¨ requestAnimationFrame å®ç°æ¸¸æˆå¾ªç¯èŠ‚æµ
let lastTime = 0
const gameLoop = (timestamp) => {
  // è®¡ç®—å¸§ç‡
  if (lastTime) {
    const delta = timestamp - lastTime
    fps.value = Math.round(1000 / delta)
  }
  lastTime = timestamp
  
  // æ¸…ç©ºç”»å¸ƒ
  ctx.value.clearRect(0, 0, 800, 500)
  
  // æ›´æ–°æ¸¸æˆçŠ¶æ€
  updatePlayer()
  updateBullets()
  updateEnemies()
  checkCollisions()
  
  // æ¸²æŸ“
  drawPlayer()
  drawBullets()
  drawEnemies()
  drawUI()
  
  // ä¸‹ä¸€å¸§
  requestAnimationFrame(gameLoop)
}

// ç©å®¶ç§»åŠ¨ï¼ˆé”®ç›˜è¾“å…¥èŠ‚æµï¼‰
const keys = {}
const keyThrottle = {}

const handleKeyDown = (event) => {
  keys[event.code] = true
  
  // ç©ºæ ¼å°„å‡»ï¼ˆèŠ‚æµæ§åˆ¶å°„å‡»é¢‘ç‡ï¼‰
  if (event.code === 'Space') {
    if (!keyThrottle.space || Date.now() - keyThrottle.space > 200) {
      fireBullet()
      keyThrottle.space = Date.now()
    }
    event.preventDefault()
  }
}

const handleKeyUp = (event) => {
  keys[event.code] = false
}

// æ›´æ–°ç©å®¶ä½ç½®ï¼ˆä½¿ç”¨èŠ‚æµæ§åˆ¶æ›´æ–°é¢‘ç‡ï¼‰
const updatePlayer = useThrottleFn(() => {
  if (keys['ArrowLeft']) player.x -= player.speed
  if (keys['ArrowRight']) player.x += player.speed
  if (keys['ArrowUp']) player.y -= player.speed
  if (keys['ArrowDown']) player.y += player.speed
  
  // è¾¹ç•Œæ£€æŸ¥
  player.x = Math.max(0, Math.min(800, player.x))
  player.y = Math.max(0, Math.min(500, player.y))
}, 16) // çº¦60fps

// å‘å°„å­å¼¹
const fireBullet = () => {
  bullets.value.push({
    x: player.x,
    y: player.y,
    speed: 10,
    width: 5,
    height: 10
  })
}

// ä½¿ç”¨ç‰¹æ®ŠæŠ€èƒ½
const useSpecialSkill = useThrottleFn(() => {
  // å‘å°„å¤šä¸ªå­å¼¹
  for (let i = 0; i < 5; i++) {
    bullets.value.push({
      x: player.x + (i * 10),
      y: player.y,
      speed: 8,
      width: 8,
      height: 15
    })
  }
}, 500) // æ¯500msæœ€å¤šä½¿ç”¨ä¸€æ¬¡

// æ›´æ–°å­å¼¹ä½ç½®
const updateBullets = () => {
  bullets.value = bullets.value.filter(bullet => {
    bullet.y -= bullet.speed
    return bullet.y > 0
  })
}

// æ›´æ–°æ•Œäºº
const updateEnemies = () => {
  enemies.value.forEach(enemy => {
    enemy.y += enemy.speed
  })
  
  enemies.value = enemies.value.filter(enemy => enemy.y < 500)
  
  // éšæœºç”Ÿæˆæ•Œäºº
  if (Math.random() < 0.02) {
    enemies.value.push({
      x: Math.random() * 800,
      y: 0,
      speed: Math.random() * 2 + 1,
      width: 30,
      height: 30
    })
  }
}

// ç¢°æ’æ£€æµ‹
const checkCollisions = () => {
  bullets.value.forEach((bullet, bIndex) => {
    enemies.value.forEach((enemy, eIndex) => {
      if (isColliding(bullet, enemy)) {
        // ç§»é™¤å­å¼¹å’Œæ•Œäºº
        bullets.value.splice(bIndex, 1)
        enemies.value.splice(eIndex, 1)
        score.value += 100
      }
    })
  })
}

// ç¢°æ’æ£€æµ‹å‡½æ•°
const isColliding = (rect1, rect2) => {
  return rect1.x < rect2.x + rect2.width &&
         rect1.x + rect1.width > rect2.x &&
         rect1.y < rect2.y + rect2.height &&
         rect1.y + rect1.height > rect2.y
}

// ç»˜åˆ¶å‡½æ•°
const drawPlayer = () => {
  ctx.value.fillStyle = '#3498db'
  ctx.value.fillRect(player.x - 15, player.y - 15, 30, 30)
}

const drawBullets = () => {
  ctx.value.fillStyle = '#e74c3c'
  bullets.value.forEach(bullet => {
    ctx.value.fillRect(bullet.x, bullet.y, bullet.width, bullet.height)
  })
}

const drawEnemies = () => {
  ctx.value.fillStyle = '#2ecc71'
  enemies.value.forEach(enemy => {
    ctx.value.fillRect(enemy.x, enemy.y, enemy.width, enemy.height)
  })
}

const drawUI = () => {
  ctx.value.fillStyle = 'white'
  ctx.value.font = '16px Arial'
  ctx.value.fillText(`åˆ†æ•°: ${score.value}`, 10, 20)
  ctx.value.fillText(`FPS: ${fps.value}`, 10, 40)
}

// åˆå§‹åŒ–æ¸¸æˆ
onMounted(() => {
  if (canvas.value) {
    ctx.value = canvas.value.getContext('2d')
    
    // å¯åŠ¨æ¸¸æˆå¾ªç¯
    requestAnimationFrame(gameLoop)
    
    // ç›‘å¬é”®ç›˜äº‹ä»¶
    window.addEventListener('keydown', handleKeyDown)
    window.addEventListener('keyup', handleKeyUp)
  }
})

onUnmounted(() => {
  window.removeEventListener('keydown', handleKeyDown)
  window.removeEventListener('keyup', handleKeyUp)
})
</script>

<style scoped>
.game-container {
  position: relative;
}

canvas {
  background: #222;
  display: block;
  margin: 0 auto;
  border: 2px solid #555;
}

.game-controls {
  margin-top: 20px;
  display: flex;
  gap: 20px;
  justify-content: center;
}

.fire-btn {
  background: #e74c3c;
  color: white;
  border: none;
  padding: 10px 20px;
  border-radius: 5px;
  cursor: pointer;
  font-size: 16px;
}

.skill-btn {
  background: #9b59b6;
  color: white;
  border: none;
  padding: 10px 20px;
  border-radius: 5px;
  cursor: pointer;
  font-size: 16px;
}

.keyboard-hint {
  color: #7f8c8d;
  font-size: 14px;
  margin-top: 5px;
}

.game-stats {
  margin-top: 20px;
  display: flex;
  justify-content: center;
  gap: 30px;
  font-family: monospace;
  font-size: 18px;
}
</style>
```

## ğŸš€ æ€§èƒ½ä¼˜åŒ–æŠ€å·§

### **1. èŠ‚æµç­–ç•¥é€‰æ‹©å™¨**
```javascript
// throttleStrategies.js
export const throttleStrategies = {
  // æ»šåŠ¨ç›¸å…³ï¼šé«˜é¢‘ç‡ï¼Œéœ€è¦æµç•…
  SCROLL: {
    delay: 16,      // çº¦60fps
    leading: true,
    trailing: true,
    maxWait: 50
  },
  
  // é¼ æ ‡ç§»åŠ¨ï¼šä¸­ç­‰é¢‘ç‡ï¼Œéœ€è¦å“åº”
  MOUSE_MOVE: {
    delay: 32,      // çº¦30fps
    leading: true,
    trailing: true,
    maxWait: 100
  },
  
  // çª—å£è°ƒæ•´ï¼šä½é¢‘ï¼Œä½†éœ€è¦å³æ—¶åé¦ˆ
  RESIZE: {
    delay: 100,
    leading: false,
    trailing: true,
    maxWait: 500
  },
  
  // æ¸¸æˆæ§åˆ¶ï¼šæé«˜é¢‘ï¼Œéœ€è¦ç²¾å‡†
  GAME_INPUT: {
    delay: 8,       // çº¦120fps
    leading: true,
    trailing: false,
    maxWait: 16
  },
  
  // ç½‘ç»œè¯·æ±‚ï¼šä½é¢‘ï¼Œé˜²æ­¢è¿‡åº¦è¯·æ±‚
  API_REQUEST: {
    delay: 1000,
    leading: true,
    trailing: false,
    maxWait: 3000
  },
  
  // å®æ—¶ä¿å­˜ï¼šä½é¢‘ï¼Œç”¨æˆ·æ— æ„Ÿ
  AUTO_SAVE: {
    delay: 3000,
    leading: false,
    trailing: true,
    maxWait: 10000
  }
}

// ç­–ç•¥å·¥å‚å‡½æ•°
export function createThrottleByStrategy(strategyName, fn) {
  const strategy = throttleStrategies[strategyName] || throttleStrategies.SCROLL
  
  return useThrottleFn(fn, strategy.delay, {
    leading: strategy.leading,
    trailing: strategy.trailing,
    maxWait: strategy.maxWait
  })
}

// ä½¿ç”¨
const handleScroll = createThrottleByStrategy('SCROLL', (event) => {
  // æ»šåŠ¨å¤„ç†
})
```

### **2. åŠ¨æ€èŠ‚æµè°ƒæ•´**
```javascript
// adaptiveThrottle.js - æ ¹æ®è®¾å¤‡æ€§èƒ½åŠ¨æ€è°ƒæ•´
export function useAdaptiveThrottle() {
  const performanceLevel = ref('high') // high | medium | low
  const baseDelay = ref(16) // åŸºç¡€å»¶è¿Ÿ
  
  // æ£€æµ‹è®¾å¤‡æ€§èƒ½
  const detectPerformance = () => {
    const start = performance.now()
    let count = 0
    
    // ç®€å•æ€§èƒ½æµ‹è¯•
    const test = () => {
      for (let i = 0; i < 1000000; i++) {
        count += Math.random()
      }
      
      const duration = performance.now() - start
      
      if (duration < 50) {
        performanceLevel.value = 'high'
        baseDelay.value = 8
      } else if (duration < 150) {
        performanceLevel.value = 'medium'
        baseDelay.value = 16
      } else {
        performanceLevel.value = 'low'
        baseDelay.value = 32
      }
    }
    
    requestAnimationFrame(test)
  }
  
  // æ ¹æ®æ€§èƒ½çº§åˆ«åˆ›å»ºèŠ‚æµå‡½æ•°
  const createAdaptiveThrottle = (fn, baseDelay) => {
    let delay = baseDelay
    
    // æ ¹æ®FPSåŠ¨æ€è°ƒæ•´
    let lastTime = 0
    let frameCount = 0
    let fps = 60
    
    const updateFPS = (timestamp) => {
      frameCount++
      
      if (lastTime && timestamp - lastTime >= 1000) {
        fps = frameCount
        frameCount = 0
        lastTime = timestamp
        
        // æ ¹æ®FPSè°ƒæ•´èŠ‚æµå»¶è¿Ÿ
        if (fps < 30) {
          delay = baseDelay * 2
        } else if (fps < 50) {
          delay = baseDelay * 1.5
        } else {
          delay = baseDelay
        }
      } else if (!lastTime) {
        lastTime = timestamp
      }
      
      requestAnimationFrame(updateFPS)
    }
    
    requestAnimationFrame(updateFPS)
    
    // è¿”å›èŠ‚æµå‡½æ•°
    return useThrottleFn(fn, delay)
  }
  
  onMounted(detectPerformance)
  
  return {
    performanceLevel,
    baseDelay,
    createAdaptiveThrottle
  }
}
```

### **3. èŠ‚æµæ‰¹å¤„ç†**
```javascript
// batchThrottle.js - æ‰¹é‡å¤„ç†èŠ‚æµäº‹ä»¶
export function useBatchThrottle() {
  const batchQueue = new Map()
  let processing = false
  
  // æ·»åŠ äº‹ä»¶åˆ°æ‰¹å¤„ç†é˜Ÿåˆ—
  const addToBatch = (key, data, processor) => {
    if (!batchQueue.has(key)) {
      batchQueue.set(key, {
        data: [],
        processor
      })
    }
    
    const batch = batchQueue.get(key)
    batch.data.push(data)
    
    // è§¦å‘æ‰¹å¤„ç†
    if (!processing) {
      processing = true
      setTimeout(processBatch, 50)
    }
  }
  
  // å¤„ç†æ‰¹å¤„ç†é˜Ÿåˆ—
  const processBatch = () => {
    batchQueue.forEach((batch, key) => {
      if (batch.data.length > 0) {
        // æ‰¹é‡å¤„ç†æ•°æ®
        batch.processor(batch.data)
        batch.data = []
      }
    })
    
    processing = false
  }
  
  // åˆ›å»ºæ‰¹å¤„ç†èŠ‚æµå‡½æ•°
  const createBatchThrottle = (key, processor, delay = 50) => {
    let lastProcessTime = 0
    
    return (data) => {
      const now = Date.now()
      
      if (now - lastProcessTime >= delay) {
        // ç«‹å³å¤„ç†
        processor([data])
        lastProcessTime = now
      } else {
        // æ·»åŠ åˆ°æ‰¹å¤„ç†é˜Ÿåˆ—
        addToBatch(key, data, processor)
      }
    }
  }
  
  return { createBatchThrottle }
}
```

## ğŸ“Š æ€§èƒ½ç›‘æ§ä¸è°ƒè¯•

### **èŠ‚æµæ€§èƒ½ç›‘æ§**
```javascript
// throttle