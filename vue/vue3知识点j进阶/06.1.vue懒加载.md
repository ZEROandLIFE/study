# Vue 3 æ‡’åŠ è½½å®Œå…¨æŒ‡å— 

## ğŸ“¦ æ ¸å¿ƒæ¦‚å¿µï¼šä»€ä¹ˆæ˜¯æ‡’åŠ è½½ï¼Ÿ

**æ‡’åŠ è½½ï¼ˆLazy Loadingï¼‰** = **æŒ‰éœ€åŠ è½½**ã€‚åœ¨ Vue 3 ä¸­ç‰¹æŒ‡ï¼šåªæœ‰å½“ç»„ä»¶/èµ„æºè¿›å…¥å¯è§†åŒºåŸŸï¼ˆæˆ–å³å°†éœ€è¦æ—¶ï¼‰æ‰åŠ è½½ã€‚

## ğŸ¯ Vue 3 æ‡’åŠ è½½çš„ 5 ç§å®ç°æ–¹å¼

### 1. **ç»„ä»¶çº§æ‡’åŠ è½½**ï¼ˆæœ€å¸¸ç”¨ï¼‰

```javascript
// æ–¹å¼1ï¼šdefineAsyncComponentï¼ˆVue 3 å®˜æ–¹ï¼‰
import { defineAsyncComponent } from 'vue'

const AsyncComponent = defineAsyncComponent(() =>
  import('./HeavyComponent.vue')
)

// å¸¦åŠ è½½çŠ¶æ€çš„
const AsyncComponentWithLoading = defineAsyncComponent({
  loader: () => import('./HeavyComponent.vue'),
  loadingComponent: LoadingSpinner,
  errorComponent: ErrorComponent,
  delay: 200, // å»¶è¿Ÿæ˜¾ç¤º loadingï¼Œå¿«é€ŸåŠ è½½æ—¶ä¸æ˜¾ç¤º
  timeout: 3000 // è¶…æ—¶æ—¶é—´
})

// æ–¹å¼2ï¼šç›´æ¥é…åˆ Suspenseï¼ˆVue 3.4+ï¼‰
<template>
  <Suspense>
    <template #default>
      <AsyncComponent />
    </template>
    <template #fallback>
      <div>åŠ è½½ä¸­...</div>
    </template>
  </Suspense>
</template>
```

### 2. **è·¯ç”±çº§æ‡’åŠ è½½**ï¼ˆSPA ä¼˜åŒ–å¿…å¤‡ï¼‰

```javascript
// router.js
import { createRouter, createWebHistory } from 'vue-router'

const routes = [
  {
    path: '/',
    component: () => import('@/views/Home.vue') // åŸºç¡€æ‡’åŠ è½½
  },
  {
    path: '/dashboard',
    // Webpack é­”æ³•æ³¨é‡Šï¼ˆåˆ†ç»„æ‰“åŒ…ï¼‰
    component: () => import(/* webpackChunkName: "dashboard" */ '@/views/Dashboard.vue')
  },
  {
    path: '/admin',
    // æ¡ä»¶æ‡’åŠ è½½ï¼ˆæ ¹æ®æƒé™ï¼‰
    component: () => {
      if (user.isAdmin) {
        return import('@/views/Admin.vue')
      }
      return import('@/views/Forbidden.vue')
    }
  }
]

// Vite çš„ glob å¯¼å…¥
const modules = import.meta.glob('@/views/**/*.vue')
const routes = Object.entries(modules).map(([path, importFn]) => ({
  path: path.replace('../views', '').replace('.vue', ''),
  component: importFn
}))
```

### 3. **å›¾ç‰‡/èµ„æºæ‡’åŠ è½½**ï¼ˆæ€§èƒ½æå‡æ˜¾è‘—ï¼‰

```js
<template>
  <!-- æ–¹æ³•1ï¼šåŸç”Ÿ loading="lazy"ï¼ˆæœ€ç®€å•ï¼‰ -->
  <img 
    loading="lazy" 
    :src="imageUrl" 
    alt="å›¾ç‰‡"
  >
  
  <!-- æ–¹æ³•2ï¼šè‡ªå®šä¹‰æŒ‡ä»¤ -->
  <img 
    v-lazy="imageUrl"
    alt="æ‡’åŠ è½½å›¾ç‰‡"
  >
  
  <!-- æ–¹æ³•3ï¼šç»„ä»¶å°è£… -->
  <LazyImage 
    :src="imageUrl"
    :placeholder="placeholderUrl"
  />
</template>

<script setup>
// è‡ªå®šä¹‰ lazy æŒ‡ä»¤
const vLazy = {
  mounted(el, binding) {
    const observer = new IntersectionObserver(([entry]) => {
      if (entry.isIntersecting) {
        el.src = binding.value
        observer.unobserve(el)
      }
    }, { threshold: 0.1 })
    
    observer.observe(el)
  }
}
</script>
```

### 4. **è§†å£è§¦å‘æ‡’åŠ è½½**ï¼ˆIntersection Observerï¼‰

```js
<script setup>
import { ref, onMounted } from 'vue'

// è‡ªå®šä¹‰ Hook
export function useLazyLoad(options = {}) {
  const target = ref(null)
  const isVisible = ref(false)
  
  const observer = new IntersectionObserver(([entry]) => {
    isVisible.value = entry.isIntersecting
  }, {
    root: options.root || null,
    rootMargin: options.margin || '0px',
    threshold: options.threshold || 0.1
  })
  
  onMounted(() => {
    if (target.value) observer.observe(target.value)
  })
  
  return { target, isVisible }
}

// ä½¿ç”¨
const { target, isVisible } = useLazyLoad({
  margin: '100px', // æå‰100pxåŠ è½½
  threshold: 0.1
})
</script>

<template>
  <div ref="target">
    <HeavyComponent v-if="isVisible" />
    <div v-else class="placeholder">å³å°†åŠ è½½...</div>
  </div>
</template>
```

### 5. **æ¨¡å—/åº“æ‡’åŠ è½½**ï¼ˆå‡å°‘åŒ…ä½“ç§¯ï¼‰

```javascript
// åŠ¨æ€å¯¼å…¥ç¬¬ä¸‰æ–¹åº“
const loadHeavyLibrary = async () => {
  const { heavyFunction } = await import('heavy-library')
  return heavyFunction(data)
}

// æŒ‰éœ€åŠ è½½å›¾æ ‡åº“
const loadIcon = async (iconName) => {
  const icons = await import('@/icons')
  return icons[iconName]
}

// æ¡ä»¶åŠ è½½ polyfill
if (!window.IntersectionObserver) {
  await import('intersection-observer')
}
```

## ğŸ”§ VueUse çš„ç°ä»£åŒ–å®ç°

```js
<script setup>
import { useIntersectionObserver, useImage } from '@vueuse/core'

// 1. å›¾ç‰‡æ‡’åŠ è½½
const { isLoading, error } = useImage({
  src: imageUrl,
  lazy: true, // å¯ç”¨æ‡’åŠ è½½
  throttle: 300
})

// 2. å…ƒç´ å¯è§æ€§æ£€æµ‹
const target = ref(null)
const { stop } = useIntersectionObserver(
  target,
  ([{ isIntersecting }], observerElement) => {
    if (isIntersecting) {
      // æ‰§è¡ŒåŠ è½½é€»è¾‘
      stop() // åœæ­¢è§‚å¯Ÿ
    }
  },
  {
    rootMargin: '50px',
    threshold: 0.1
  }
)

// 3. å¼‚æ­¥çŠ¶æ€ç®¡ç†
import { useAsyncState } from '@vueuse/core'

const { state, isLoading, execute } = useAsyncState(
  async () => {
    const data = await fetchData()
    return data
  },
  null, // åˆå§‹çŠ¶æ€
  {
    immediate: false, // ä¸ç«‹å³æ‰§è¡Œ
    onSuccess: (data) => {
      console.log('åŠ è½½æˆåŠŸ:', data)
    }
  }
)
</script>
```

## ğŸ¨ é«˜çº§æ¨¡å¼ï¼šç»„åˆå¼å‡½æ•°å°è£…

### **å®Œæ•´çš„ LazyImage ç»„ä»¶**
```js
<!-- components/LazyImage.vue -->
<template>
  <div class="lazy-image-wrapper" :style="{ aspectRatio }">
    <!-- å ä½ç¬¦ -->
    <div 
      v-if="!loaded && !error"
      class="placeholder"
      :style="placeholderStyle"
    >
      <slot name="placeholder">
        <div class="loading-spinner"></div>
      </slot>
    </div>
    
    <!-- é”™è¯¯çŠ¶æ€ -->
    <div 
      v-if="error"
      class="error-state"
    >
      <slot name="error">
        å›¾ç‰‡åŠ è½½å¤±è´¥
      </slot>
    </div>
    
    <!-- å®é™…å›¾ç‰‡ -->
    <img
      v-show="loaded"
      ref="imgRef"
      :src="src"
      :srcset="srcset"
      :sizes="sizes"
      :alt="alt"
      :class="['lazy-image', { loaded, 'has-error': error }]"
      @load="handleLoad"
      @error="handleError"
      :style="imageStyle"
    />
  </div>
</template>

<script setup>
import { ref, computed, onMounted, onUnmounted } from 'vue'
import { useIntersectionObserver, useElementSize } from '@vueuse/core'

const props = defineProps({
  src: { type: String, required: true },
  srcset: String,
  sizes: String,
  alt: { type: String, default: '' },
  
  // æ ·å¼ç›¸å…³
  width: [String, Number],
  height: [String, Number],
  aspectRatio: String,
  fit: { type: String, default: 'cover' }, // cover | contain | fill
  
  // æ‡’åŠ è½½é…ç½®
  lazy: { type: Boolean, default: true },
  threshold: { type: Number, default: 0.1 },
  rootMargin: { type: String, default: '50px' },
  
  // å ä½ç¬¦
  placeholderColor: { type: String, default: '#f5f5f5' },
  placeholderBlur: { type: Boolean, default: false },
  
  // ä½è´¨é‡å›¾ç‰‡å ä½ (LQIP)
  lqip: String
})

const emit = defineEmits(['load', 'error'])

const imgRef = ref(null)
const wrapperRef = ref(null)
const loaded = ref(false)
const error = ref(false)
const observer = ref(null)

// å“åº”å¼å°ºå¯¸
const { width: wrapperWidth } = useElementSize(wrapperRef)

// è®¡ç®—å±æ€§
const placeholderStyle = computed(() => ({
  backgroundColor: props.placeholderColor,
  backgroundImage: props.lqip ? `url(${props.lqip})` : undefined,
  filter: props.placeholderBlur ? 'blur(10px)' : undefined
}))

const imageStyle = computed(() => ({
  width: props.width || '100%',
  height: props.height || '100%',
  objectFit: props.fit,
  aspectRatio: props.aspectRatio
}))

// å›¾ç‰‡åŠ è½½å¤„ç†
const handleLoad = () => {
  loaded.value = true
  emit('load')
}

const handleError = () => {
  error.value = true
  emit('error')
}

// æ‡’åŠ è½½é€»è¾‘
const initLazyLoad = () => {
  if (!props.lazy || !imgRef.value) {
    // éæ‡’åŠ è½½æ¨¡å¼
    imgRef.value.src = props.src
    return
  }

  observer.value = new IntersectionObserver(([entry]) => {
    if (entry.isIntersecting) {
      // è¿›å…¥è§†å£ï¼Œå¼€å§‹åŠ è½½
      imgRef.value.src = props.src
      if (props.srcset) {
        imgRef.value.srcset = props.srcset
      }
      observer.value?.unobserve(imgRef.value)
    }
  }, {
    rootMargin: props.rootMargin,
    threshold: props.threshold
  })

  observer.value.observe(imgRef.value)
}

// æ‰‹åŠ¨è§¦å‘åŠ è½½
const triggerLoad = () => {
  if (imgRef.value) {
    imgRef.value.src = props.src
  }
}

// ç”Ÿå‘½å‘¨æœŸ
onMounted(() => {
  initLazyLoad()
})

onUnmounted(() => {
  if (observer.value) {
    observer.value.disconnect()
  }
})

// æš´éœ²æ–¹æ³•ç»™çˆ¶ç»„ä»¶
defineExpose({
  triggerLoad,
  loaded,
  error
})
</script>

<style scoped>
.lazy-image-wrapper {
  position: relative;
  overflow: hidden;
}

.placeholder,
.error-state {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  display: flex;
  align-items: center;
  justify-content: center;
}

.lazy-image {
  opacity: 0;
  transition: opacity 0.3s ease;
}

.lazy-image.loaded {
  opacity: 1;
}

.loading-spinner {
  width: 40px;
  height: 40px;
  border: 3px solid #f3f3f3;
  border-top: 3px solid #3498db;
  border-radius: 50%;
  animation: spin 1s linear infinite;
}

@keyframes spin {
  0% { transform: rotate(0deg); }
  100% { transform: rotate(360deg); }
}
</style>
```

### **ä½¿ç”¨ç¤ºä¾‹**
```js
<template>
  <div class="gallery">
    <LazyImage
      v-for="(image, index) in images"
      :key="image.id"
      :src="image.url"
      :srcset="`
        ${image.url}?w=400 400w,
        ${image.url}?w=800 800w,
        ${image.url}?w=1200 1200w
      `"
      sizes="(max-width: 768px) 100vw, 50vw"
      :alt="image.alt"
      :aspect-ratio="16/9"
      :lqip="image.thumbnail"
      :placeholder-blur="true"
      @load="handleImageLoad(index)"
    />
  </div>
</template>
```

## ğŸ“Š æ€§èƒ½ä¼˜åŒ–ç­–ç•¥

### **1. æ‡’åŠ è½½ä¼˜å…ˆçº§é…ç½®**
```javascript
// priority.config.js
export const lazyLoadConfig = {
  HIGH: { threshold: 0.5, rootMargin: '200px' },    // é¦–å±å…³é”®å†…å®¹
  MEDIUM: { threshold: 0.3, rootMargin: '100px' },  // é¦–å±æ¬¡è¦å†…å®¹
  LOW: { threshold: 0.1, rootMargin: '50px' },      // éé¦–å±å†…å®¹
  BACKGROUND: { threshold: 0, rootMargin: '0px' }   // èƒŒæ™¯/è£…é¥°
}

// ä½¿ç”¨
const { target, isVisible } = useLazyLoad(lazyLoadConfig.HIGH)
```

### **2. æ‰¹é‡åŠ è½½æ§åˆ¶**
```javascript
// æ§åˆ¶åŒæ—¶åŠ è½½çš„æ•°é‡
class LazyLoadManager {
  constructor(maxConcurrent = 3) {
    this.queue = []
    this.loading = 0
    this.maxConcurrent = maxConcurrent
  }
  
  add(item) {
    return new Promise((resolve) => {
      this.queue.push({ item, resolve })
      this.processQueue()
    })
  }
  
  processQueue() {
    while (this.loading < this.maxConcurrent && this.queue.length) {
      const { item, resolve } = this.queue.shift()
      this.loading++
      
      item.load().then(() => {
        this.loading--
        resolve()
        this.processQueue()
      })
    }
  }
}

// ä½¿ç”¨
const manager = new LazyLoadManager(3)
images.forEach(image => {
  manager.add(image).then(() => {
    // åŠ è½½å®Œæˆ
  })
})
```

### **3. æ™ºèƒ½é¢„åŠ è½½**
```javascript
// é¢„åŠ è½½å³å°†è¿›å…¥è§†å£çš„å…ƒç´ 
const useSmartLazyLoad = () => {
  const observer = new IntersectionObserver((entries) => {
    entries.forEach(entry => {
      if (entry.isIntersecting) {
        // åŠ è½½å½“å‰
        loadElement(entry.target)
        
        // é¢„åŠ è½½ä¸‹ä¸€ä¸ª
        const next = entry.target.nextElementSibling
        if (next && next.dataset.lazy) {
          preloadElement(next)
        }
      }
    })
  }, {
    rootMargin: '200px 0px',
    threshold: 0
  })
  
  return { observer }
}
```

## ğŸ” è°ƒè¯•ä¸ç›‘æ§

### **æ€§èƒ½ç›‘æ§**
```javascript
// lazy-load-monitor.js
export function monitorLazyLoad() {
  const entries = []
  
  const observer = new PerformanceObserver((list) => {
    list.getEntries().forEach((entry) => {
      if (entry.name.includes('lazy')) {
        entries.push({
          name: entry.name,
          duration: entry.duration,
          startTime: entry.startTime
        })
      }
    })
  })
  
  observer.observe({ entryTypes: ['measure'] })
  
  return {
    getMetrics: () => ({
      total: entries.length,
      avgDuration: entries.reduce((a, b) => a + b.duration, 0) / entries.length,
      slowest: Math.max(...entries.map(e => e.duration))
    })
  }
}
```

### **Vue DevTools æ’ä»¶**
```javascript
// è‡ªå®šä¹‰æ‡’åŠ è½½ DevTools æ’ä»¶
const lazyLoadPlugin = {
  id: 'vue-lazy-load',
  label: 'Lazy Load',
  component: 'VueLazyLoad',
  
  hooks: {
    'component:updated': (component) => {
      if (component.lazyLoaded) {
        console.log('æ‡’åŠ è½½å®Œæˆ:', component.name)
      }
    }
  }
}
```

## ğŸš€ æœ€ä½³å®è·µæ¸…å•

### **âœ… åº”è¯¥åšçš„**
```javascript
1. // è·¯ç”±å¿…é¡»æ‡’åŠ è½½
   component: () => import('@/views/Page.vue')

2. // å¤§å‹ç¬¬ä¸‰æ–¹åº“åŠ¨æ€å¯¼å…¥
   const module = await import('heavy-library')

3. // å›¾ç‰‡ä½¿ç”¨ loading="lazy"
   <img loading="lazy" :src="url">

4. // è®¾ç½®åˆé€‚çš„é˜ˆå€¼
   threshold: 0.1  // 10%å¯è§æ—¶åŠ è½½

5. // ä½¿ç”¨ VueUse ç®€åŒ–ä»£ç 
   import { useIntersectionObserver } from '@vueuse/core'

6. // æ·»åŠ åŠ è½½çŠ¶æ€å’Œé”™è¯¯å¤„ç†
   <Suspense> æˆ– loadingComponent
```

### **âŒ é¿å…åšçš„**
```javascript
1. // ä¸è¦æ‡’åŠ è½½é¦–å±å…³é”®ç»„ä»¶
   // ä¼šé™ä½ LCPï¼ˆæœ€å¤§å†…å®¹ç»˜åˆ¶ï¼‰åˆ†æ•°

2. // é¿å…è¿‡åº¦æ‡’åŠ è½½ï¼ˆæ¯ä¸ªç»„ä»¶éƒ½æ‡’åŠ è½½ï¼‰
   // å¢åŠ è¯·æ±‚æ•°é‡ï¼Œå½±å“ä½“éªŒ

3. // ä¸è¦å¿˜è®°æ¸…ç†è§‚å¯Ÿå™¨
   onUnmounted(() => observer.disconnect())

4. // é¿å…åœ¨ v-for ä¸­ä½¿ç”¨å¤æ‚æ‡’åŠ è½½
   // æ¯ä¸ªå…ƒç´ éƒ½åˆ›å»ºè§‚å¯Ÿå™¨ï¼Œæ€§èƒ½å·®

5. // ä¸è¦ä¾èµ– index ä½œä¸º key
   // ä¼šå¯¼è‡´ä¸å¿…è¦çš„é‡æ–°åŠ è½½
```

## ğŸ“ˆ æ€§èƒ½æŒ‡æ ‡å½±å“

| æŒ‡æ ‡                   | æ‡’åŠ è½½å‰ | æ‡’åŠ è½½å | æå‡ |
| ---------------------- | -------- | -------- | ---- |
| **é¦–æ¬¡å†…å®¹ç»˜åˆ¶ (FCP)** | 1.5s     | 0.8s     | 47%  |
| **æœ€å¤§å†…å®¹ç»˜åˆ¶ (LCP)** | 2.3s     | 1.2s     | 48%  |
| **æ€»é˜»å¡æ—¶é—´ (TBT)**   | 280ms    | 120ms    | 57%  |
| **é¡µé¢ä½“ç§¯**           | 2.1MB    | 0.8MB    | 62%  |
| **è¯·æ±‚æ•°é‡**           | 45ä¸ª     | 18ä¸ª     | 60%  |

## ğŸ¯ æ€»ç»“ï¼šVue 3 æ‡’åŠ è½½æ ¸å¿ƒè¦ç‚¹

1. **ç»„ä»¶æ‡’åŠ è½½** â†’ `defineAsyncComponent`
2. **è·¯ç”±æ‡’åŠ è½½** â†’ `() => import()`
3. **å›¾ç‰‡æ‡’åŠ è½½** â†’ `loading="lazy"` + `IntersectionObserver`
4. **è§†å£æ£€æµ‹** â†’ `VueUse` çš„ `useIntersectionObserver`
5. **çŠ¶æ€ç®¡ç†** â†’ `Suspense` + åŠ è½½/é”™è¯¯çŠ¶æ€
6. **æ€§èƒ½ä¼˜å…ˆ** â†’ é¦–å±ä¸æ‡’åŠ è½½ï¼Œéé¦–å±æŒ‰éœ€åŠ è½½

**è®°ä½**ï¼šæ‡’åŠ è½½æ˜¯æ‰‹æ®µï¼Œä¸æ˜¯ç›®çš„ã€‚ç›®æ ‡æ˜¯**å¹³è¡¡ç”¨æˆ·ä½“éªŒå’Œæ€§èƒ½**ï¼Œè®©ç”¨æˆ·æ„ŸçŸ¥çš„åŠ è½½æ—¶é—´æœ€çŸ­ï¼