# Vue 3 é˜²æŠ–å®Œå…¨æŒ‡å— â±ï¸

## ğŸ¯ é˜²æŠ–åœ¨ Vue 3 ä¸­çš„æ ¸å¿ƒæ¦‚å¿µ

**é˜²æŠ–ï¼ˆDebounceï¼‰**ï¼šé«˜é¢‘äº‹ä»¶è§¦å‘æ—¶ï¼Œåªæ‰§è¡Œæœ€åä¸€æ¬¡ï¼Œå¿½ç•¥ä¸­é—´è¿‡ç¨‹ã€‚

## ğŸ”§ 6 ç§ Vue 3 é˜²æŠ–å®ç°æ–¹å¼

### 1. **Composition API åŸç”Ÿå®ç°**
```javascript
// useDebounce.js
import { ref, onUnmounted } from 'vue'

export function useDebounce(fn, delay = 300) {
  let timer = null
  const debouncedFn = (...args) => {
    if (timer) clearTimeout(timer)
    timer = setTimeout(() => {
      fn(...args)
    }, delay)
  }
  
  // æ¸…ç†å‡½æ•°
  const cancel = () => {
    if (timer) {
      clearTimeout(timer)
      timer = null
    }
  }
  
  // ç«‹å³æ‰§è¡Œç‰ˆæœ¬
  const debounceImmediate = (fn, delay = 300) => {
    let timer = null
    return (...args) => {
      if (!timer) fn(...args)  // é¦–æ¬¡ç«‹å³æ‰§è¡Œ
      if (timer) clearTimeout(timer)
      timer = setTimeout(() => {
        timer = null
      }, delay)
    }
  }
  
  onUnmounted(cancel)
  
  return {
    debouncedFn,
    cancel,
    debounceImmediate
  }
}
```

### 2. **ç»„ä»¶å†…ç›´æ¥ä½¿ç”¨**
```vue
<script setup>
import { ref } from 'vue'

const searchInput = ref('')
let timer = null

// åŸºæœ¬é˜²æŠ–
const handleSearch = (value) => {
  if (timer) clearTimeout(timer)
  timer = setTimeout(() => {
    console.log('æœç´¢:', value)
    // APIè°ƒç”¨...
  }, 500)
}

// å¸¦å‚æ•°çš„é˜²æŠ–
const debounce = (fn, delay = 300) => {
  let timer = null
  return (...args) => {
    if (timer) clearTimeout(timer)
    timer = setTimeout(() => {
      fn.apply(this, args)
    }, delay)
  }
}

// ä½¿ç”¨
const searchApi = (keyword) => {
  console.log('è°ƒç”¨API:', keyword)
}

const debouncedSearch = debounce(searchApi, 500)
</script>

<template>
  <input 
    v-model="searchInput" 
    @input="(e) => handleSearch(e.target.value)"
    placeholder="è¾“å…¥æœç´¢..."
  />
  
  <!-- æˆ–è€… -->
  <input 
    @input="(e) => debouncedSearch(e.target.value)"
  />
</template>
```

### 3. **å“åº”å¼é˜²æŠ–ï¼ˆä¸ ref ç»“åˆï¼‰**
```vue
<script setup>
import { ref, watch, computed } from 'vue'

// 1. watch ä¸­ä½¿ç”¨é˜²æŠ–
const searchKeyword = ref('')

watch(
  searchKeyword,
  debounce((newVal) => {
    if (newVal.trim()) {
      fetchResults(newVal)
    }
  }, 500)
)

// 2. computed é˜²æŠ–ï¼ˆå¤æ‚è®¡ç®—æ—¶ï¼‰
const expensiveValue = computed(() => {
  // å¤æ‚è®¡ç®—...
  return heavyCalculation()
})

const debouncedValue = ref('')
watch(
  expensiveValue,
  debounce((newVal) => {
    debouncedValue.value = newVal
  }, 300)
)

// 3. è‡ªå®šä¹‰é˜²æŠ– ref
function useDebouncedRef(initialValue, delay = 300) {
  const value = ref(initialValue)
  let timer = null
  
  const setValue = (newValue) => {
    if (timer) clearTimeout(timer)
    timer = setTimeout(() => {
      value.value = newValue
    }, delay)
  }
  
  return {
    value,
    setValue
  }
}

// ä½¿ç”¨
const debouncedInput = useDebouncedRef('', 500)
</script>
```

### 4. **è‡ªå®šä¹‰æŒ‡ä»¤å®ç°**
```javascript
// directives/debounce.js
export const vDebounce = {
  mounted(el, binding) {
    const { value: fn, arg: delay = 300 } = binding
    let timer = null
    
    const handler = (event) => {
      if (timer) clearTimeout(timer)
      timer = setTimeout(() => {
        fn(event)
      }, delay)
    }
    
    // å­˜å‚¨ handler ç”¨äºæ¸…ç†
    el._debounceHandler = handler
    
    // ç›‘å¬äº‹ä»¶ï¼ˆæ”¯æŒå¤šä¸ªäº‹ä»¶ï¼‰
    const events = binding.modifiers.click ? ['click'] : 
                   binding.modifiers.input ? ['input'] : ['input']
    
    events.forEach(eventName => {
      el.addEventListener(eventName, handler)
    })
  },
  unmounted(el) {
    // æ¸…ç†äº‹ä»¶ç›‘å¬å™¨
    if (el._debounceHandler) {
      el.removeEventListener('input', el._debounceHandler)
      el.removeEventListener('click', el._debounceHandler)
    }
  }
}

// å…¨å±€æ³¨å†Œ
import { createApp } from 'vue'
import { vDebounce } from './directives/debounce'

const app = createApp(App)
app.directive('debounce', vDebounce)
```

```vue
<!-- ä½¿ç”¨è‡ªå®šä¹‰æŒ‡ä»¤ -->
<template>
  <!-- è¾“å…¥æ¡†é˜²æŠ– -->
  <input 
    v-debounce:500="handleInput"
    placeholder="è¾“å…¥é˜²æŠ–..."
  />
  
  <!-- ç‚¹å‡»é˜²æŠ– -->
  <button 
    v-debounce.click:1000="handleClick"
  >
    é˜²æŠ–æŒ‰é’®
  </button>
  
  <!-- å¸¦å‚æ•° -->
  <input 
    v-debounce="(e) => search(e.target.value)"
  />
</template>
```

### 5. **VueUse çš„ useDebounceFn**
```vue
<script setup>
import { ref } from 'vue'
import { useDebounceFn, watchDebounced } from '@vueuse/core'

// 1. useDebounceFn - æœ€å¸¸ç”¨
const searchKeyword = ref('')
const results = ref([])

// åˆ›å»ºé˜²æŠ–å‡½æ•°
const debouncedSearch = useDebounceFn(async (keyword) => {
  if (!keyword.trim()) return
  
  const data = await fetch(`/api/search?q=${keyword}`)
  results.value = data
}, 500)

// åœ¨è¾“å…¥æ—¶è°ƒç”¨
const handleInput = (e) => {
  debouncedSearch(e.target.value)
}

// 2. watchDebounced - ç›‘å¬é˜²æŠ–
watchDebounced(
  searchKeyword,
  async (newVal) => {
    if (newVal.trim()) {
      const data = await fetch(`/api/search?q=${newVal}`)
      results.value = data
    }
  },
  { debounce: 500, maxWait: 1000 } // æœ€å¤§ç­‰å¾…æ—¶é—´
)

// 3. é˜²æŠ– ref
import { debouncedRef } from '@vueuse/core'
const debouncedValue = debouncedRef('', 500)
</script>
```

### 6. **é«˜çº§é˜²æŠ– Hook**
```javascript
// useAdvancedDebounce.js
import { ref, onUnmounted } from 'vue'

export function useAdvancedDebounce(options = {}) {
  const {
    delay = 300,
    immediate = false, // æ˜¯å¦ç«‹å³æ‰§è¡Œ
    maxWait = null,    // æœ€å¤§ç­‰å¾…æ—¶é—´
    trailing = true,   // å»¶è¿Ÿç»“æŸåæ˜¯å¦æ‰§è¡Œ
    leading = false    // å»¶è¿Ÿå¼€å§‹å‰æ˜¯å¦æ‰§è¡Œ
  } = options

  let timer = null
  let lastCallTime = 0
  let lastInvokeTime = 0
  let lastArgs = null
  let lastThis = null

  const invokeFunc = (time) => {
    const args = lastArgs
    const thisArg = lastThis
    
    lastArgs = lastThis = null
    lastInvokeTime = time
    
    return fn.apply(thisArg, args)
  }

  const startTimer = (pendingFunc, wait) => {
    timer = setTimeout(pendingFunc, wait)
  }

  const shouldInvoke = (time) => {
    const timeSinceLastCall = time - lastCallTime
    const timeSinceLastInvoke = time - lastInvokeTime
    
    return (
      lastCallTime === 0 ||
      timeSinceLastCall >= delay ||
      (maxWait !== null && timeSinceLastInvoke >= maxWait)
    )
  }

  const remainingWait = (time) => {
    const timeSinceLastCall = time - lastCallTime
    const timeSinceLastInvoke = time - lastInvokeTime
    const timeWaiting = delay - timeSinceLastCall
    
    return maxWait === null
      ? timeWaiting
      : Math.min(timeWaiting, maxWait - timeSinceLastInvoke)
  }

  const debounced = function(...args) {
    const time = Date.now()
    const isInvoking = shouldInvoke(time)
    
    lastArgs = args
    lastThis = this
    lastCallTime = time
    
    if (isInvoking) {
      if (timer === null) {
        if (leading) {
          return invokeFunc(time)
        }
      }
      
      if (maxWait !== null) {
        timer = setTimeout(() => {
          if (trailing && lastArgs) {
            return invokeFunc(Date.now())
          }
          timer = null
        }, delay)
        
        if (immediate) {
          return invokeFunc(time)
        }
      }
    }
    
    if (timer === null) {
      timer = setTimeout(() => {
        if (trailing && lastArgs) {
          return invokeFunc(Date.now())
        }
        timer = null
      }, delay)
    }
  }

  const cancel = () => {
    if (timer !== null) {
      clearTimeout(timer)
    }
    lastInvokeTime = 0
    lastArgs = lastCallTime = lastThis = timer = null
  }

  const flush = () => {
    return timer === null ? undefined : invokeFunc(Date.now())
  }

  onUnmounted(cancel)

  return {
    debounced,
    cancel,
    flush
  }
}
```

## ğŸ¨ å®é™…åº”ç”¨åœºæ™¯

### **åœºæ™¯1ï¼šæœç´¢æ¡†é˜²æŠ–**
```vue
<template>
  <div class="search-container">
    <!-- æ–¹æ¡ˆ1ï¼šç›´æ¥ä½¿ç”¨ -->
    <input
      v-model="keyword"
      @input="handleSearch"
      placeholder="æœç´¢å•†å“..."
      class="search-input"
    />
    
    <!-- æ–¹æ¡ˆ2ï¼šä½¿ç”¨è‡ªå®šä¹‰æŒ‡ä»¤ -->
    <input
      v-debounce:500="search"
      placeholder="æŒ‡ä»¤æ–¹å¼æœç´¢..."
    />
    
    <!-- æ–¹æ¡ˆ3ï¼šä½¿ç”¨ VueUse -->
    <input
      @input="(e) => debouncedSearch(e.target.value)"
      placeholder="VueUse æ–¹å¼..."
    />
    
    <!-- åŠ è½½çŠ¶æ€ -->
    <div v-if="loading" class="loading">
      æœç´¢ä¸­...
    </div>
    
    <!-- ç»“æœå±•ç¤º -->
    <div v-if="results.length" class="results">
      <div 
        v-for="item in results" 
        :key="item.id"
        class="result-item"
      >
        {{ item.name }}
      </div>
    </div>
  </div>
</template>

<script setup>
import { ref } from 'vue'
import { useDebounceFn } from '@vueuse/core'

const keyword = ref('')
const results = ref([])
const loading = ref(false)

// API è°ƒç”¨
const searchAPI = async (query) => {
  if (!query.trim()) {
    results.value = []
    return
  }
  
  loading.value = true
  try {
    const response = await fetch(`/api/search?q=${encodeURIComponent(query)}`)
    const data = await response.json()
    results.value = data
  } catch (error) {
    console.error('æœç´¢å¤±è´¥:', error)
    results.value = []
  } finally {
    loading.value = false
  }
}

// æ–¹æ³•1ï¼šæ‰‹åŠ¨é˜²æŠ–
let searchTimer = null
const handleSearch = () => {
  if (searchTimer) clearTimeout(searchTimer)
  searchTimer = setTimeout(() => {
    searchAPI(keyword.value)
  }, 500)
}

// æ–¹æ³•2ï¼šVueUse é˜²æŠ–
const debouncedSearch = useDebounceFn(searchAPI, 500)

// æ–¹æ³•3ï¼šç«‹å³æ‰§è¡Œçš„é˜²æŠ–ï¼ˆé¦–æ¬¡è¾“å…¥ç«‹å³æœç´¢ï¼‰
const immediateSearch = (query) => {
  if (!query.trim()) return
  
  if (searchTimer) clearTimeout(searchTimer)
  
  // å¦‚æœæ˜¯ç¬¬ä¸€æ¬¡è¾“å…¥ï¼Œç«‹å³æœç´¢
  if (!keyword.value && query) {
    searchAPI(query)
  } else {
    searchTimer = setTimeout(() => {
      searchAPI(query)
    }, 500)
  }
}
</script>
```

### **åœºæ™¯2ï¼šè¡¨å•è¾“å…¥é˜²æŠ–éªŒè¯**
```vue
<template>
  <form @submit.prevent="handleSubmit">
    <!-- ç”¨æˆ·åå®æ—¶éªŒè¯ -->
    <div class="form-group">
      <label>ç”¨æˆ·å</label>
      <input
        v-model="form.username"
        @input="validateUsername"
        :class="{ 'error': usernameError }"
      />
      <div v-if="usernameError" class="error-message">
        {{ usernameError }}
      </div>
      <div v-if="validating" class="validating">
        æ£€æŸ¥ç”¨æˆ·å...
      </div>
    </div>
    
    <!-- é‚®ç®±é˜²æŠ–éªŒè¯ -->
    <div class="form-group">
      <label>é‚®ç®±</label>
      <input
        v-model="form.email"
        @input="debouncedValidateEmail"
        :class="{ 'error': emailError }"
      />
      <div v-if="emailError" class="error-message">
        {{ emailError }}
      </div>
    </div>
    
    <button type="submit" :disabled="isSubmitting">
      {{ isSubmitting ? 'æäº¤ä¸­...' : 'æäº¤' }}
    </button>
  </form>
</template>

<script setup>
import { ref } from 'vue'
import { useDebounceFn } from '@vueuse/core'

const form = ref({
  username: '',
  email: ''
})

const usernameError = ref('')
const emailError = ref('')
const validating = ref(false)
const isSubmitting = ref(false)

// ç”¨æˆ·åéªŒè¯ï¼ˆå¸¦é˜²æŠ–ï¼‰
let validateTimer = null
const validateUsername = async () => {
  if (validateTimer) clearTimeout(validateTimer)
  
  const username = form.value.username
  
  if (!username) {
    usernameError.value = 'ç”¨æˆ·åä¸èƒ½ä¸ºç©º'
    return
  }
  
  if (username.length < 3) {
    usernameError.value = 'ç”¨æˆ·åè‡³å°‘3ä¸ªå­—ç¬¦'
    return
  }
  
  // é˜²æŠ–ï¼šç­‰å¾…ç”¨æˆ·åœæ­¢è¾“å…¥
  validateTimer = setTimeout(async () => {
    validating.value = true
    try {
      // æ£€æŸ¥ç”¨æˆ·åæ˜¯å¦å¯ç”¨
      const response = await fetch(`/api/check-username?username=${username}`)
      const { available } = await response.json()
      
      if (!available) {
        usernameError.value = 'ç”¨æˆ·åå·²å­˜åœ¨'
      } else {
        usernameError.value = ''
      }
    } catch (error) {
      usernameError.value = 'éªŒè¯å¤±è´¥ï¼Œè¯·é‡è¯•'
    } finally {
      validating.value = false
    }
  }, 500)
}

// é‚®ç®±éªŒè¯ï¼ˆä½¿ç”¨ VueUseï¼‰
const validateEmail = async (email) => {
  const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/
  
  if (!email) {
    emailError.value = 'é‚®ç®±ä¸èƒ½ä¸ºç©º'
    return
  }
  
  if (!emailRegex.test(email)) {
    emailError.value = 'é‚®ç®±æ ¼å¼ä¸æ­£ç¡®'
    return
  }
  
  // æ£€æŸ¥é‚®ç®±æ˜¯å¦å·²æ³¨å†Œ
  try {
    const response = await fetch(`/api/check-email?email=${email}`)
    const { registered } = await response.json()
    
    if (registered) {
      emailError.value = 'é‚®ç®±å·²æ³¨å†Œ'
    } else {
      emailError.value = ''
    }
  } catch (error) {
    emailError.value = 'éªŒè¯å¤±è´¥'
  }
}

const debouncedValidateEmail = useDebounceFn((e) => {
  validateEmail(e.target.value)
}, 500)
</script>
```

### **åœºæ™¯3ï¼šçª—å£ resize é˜²æŠ–**
```vue
<script setup>
import { ref, onMounted, onUnmounted } from 'vue'

const windowSize = ref({
  width: window.innerWidth,
  height: window.innerHeight
})

const deviceType = ref('desktop')

// é˜²æŠ–çš„ resize å¤„ç†
let resizeTimer = null
const handleResize = () => {
  if (resizeTimer) clearTimeout(resizeTimer)
  
  resizeTimer = setTimeout(() => {
    windowSize.value = {
      width: window.innerWidth,
      height: window.innerHeight
    }
    
    // æ ¹æ®å®½åº¦åˆ¤æ–­è®¾å¤‡ç±»å‹
    if (window.innerWidth < 768) {
      deviceType.value = 'mobile'
    } else if (window.innerWidth < 1024) {
      deviceType.value = 'tablet'
    } else {
      deviceType.value = 'desktop'
    }
    
    // è§¦å‘å¸ƒå±€æ›´æ–°
    updateLayout()
  }, 200)
}

// å¸ƒå±€æ›´æ–°å‡½æ•°
const updateLayout = () => {
  // æ ¹æ®è®¾å¤‡ç±»å‹æ›´æ–°å¸ƒå±€
  switch (deviceType.value) {
    case 'mobile':
      // ç§»åŠ¨ç«¯å¸ƒå±€
      break
    case 'tablet':
      // å¹³æ¿å¸ƒå±€
      break
    case 'desktop':
      // æ¡Œé¢å¸ƒå±€
      break
  }
}

onMounted(() => {
  window.addEventListener('resize', handleResize)
})

onUnmounted(() => {
  window.removeEventListener('resize', handleResize)
  if (resizeTimer) clearTimeout(resizeTimer)
})
</script>

<template>
  <div :class="['container', `device-${deviceType}`]">
    <div>çª—å£å°ºå¯¸: {{ windowSize.width }} x {{ windowSize.height }}</div>
    <div>è®¾å¤‡ç±»å‹: {{ deviceType }}</div>
  </div>
</template>

<style scoped>
.container {
  padding: 20px;
}

.device-mobile {
  max-width: 100%;
  font-size: 14px;
}

.device-tablet {
  max-width: 768px;
  font-size: 16px;
}

.device-desktop {
  max-width: 1200px;
  font-size: 18px;
}
</style>
```

## ğŸš€ æ€§èƒ½ä¼˜åŒ–æŠ€å·§

### **1. é˜²æŠ–å™¨å¤ç”¨æ± **
```javascript
// debouncePool.js - é¿å…é‡å¤åˆ›å»ºé˜²æŠ–å™¨
class DebouncePool {
  constructor() {
    this.pool = new Map()
  }
  
  get(key, fn, delay = 300) {
    if (this.pool.has(key)) {
      return this.pool.get(key)
    }
    
    const debouncedFn = this.createDebounce(fn, delay)
    this.pool.set(key, debouncedFn)
    
    return debouncedFn
  }
  
  createDebounce(fn, delay) {
    let timer = null
    return (...args) => {
      if (timer) clearTimeout(timer)
      timer = setTimeout(() => {
        fn(...args)
      }, delay)
    }
  }
  
  clear(key) {
    if (this.pool.has(key)) {
      this.pool.delete(key)
    }
  }
  
  clearAll() {
    this.pool.clear()
  }
}

// ä½¿ç”¨
const pool = new DebouncePool()

// åœ¨ç»„ä»¶ä¸­ä½¿ç”¨
const handleSearch = pool.get(
  'search-input', 
  (value) => searchAPI(value), 
  500
)
```

### **2. è‡ªåŠ¨æ¸…ç†é˜²æŠ–å™¨**
```javascript
// useAutoCleanDebounce.js
import { onScopeDispose } from 'vue'

export function useAutoCleanDebounce() {
  const timers = new Set()
  
  const debounce = (fn, delay = 300) => {
    let timer = null
    
    const wrappedFn = (...args) => {
      if (timer) clearTimeout(timer)
      timer = setTimeout(() => {
        fn(...args)
      }, delay)
      
      timers.add(timer)
    }
    
    // æ·»åŠ å–æ¶ˆæ–¹æ³•
    wrappedFn.cancel = () => {
      if (timer) {
        clearTimeout(timer)
        timers.delete(timer)
      }
    }
    
    return wrappedFn
  }
  
  // ç»„ä»¶å¸è½½æ—¶è‡ªåŠ¨æ¸…ç†æ‰€æœ‰å®šæ—¶å™¨
  onScopeDispose(() => {
    timers.forEach(timer => clearTimeout(timer))
    timers.clear()
  })
  
  return { debounce }
}
```

### **3. é˜²æŠ–é…ç½®ç­–ç•¥**
```javascript
// debounceStrategies.js
export const debounceStrategies = {
  // æœç´¢åœºæ™¯ï¼šä¸­ç­‰å»¶è¿Ÿ
  SEARCH: {
    delay: 500,
    maxWait: 2000,
    immediate: false
  },
  
  // è¡¨å•éªŒè¯ï¼šå¿«é€Ÿå“åº”
  VALIDATION: {
    delay: 300,
    maxWait: 1000,
    immediate: false
  },
  
  // çª—å£è°ƒæ•´ï¼šå¹³æ»‘è¿‡æ¸¡
  RESIZE: {
    delay: 200,
    maxWait: 500,
    immediate: false
  },
  
  // æŒ‰é’®ç‚¹å‡»ï¼šé˜²æ­¢é‡å¤æäº¤
  BUTTON: {
    delay: 1000,
    maxWait: 3000,
    immediate: true
  },
  
  // å®æ—¶ä¿å­˜ï¼šç”¨æˆ·æ— æ„Ÿ
  AUTO_SAVE: {
    delay: 1000,
    maxWait: 5000,
    immediate: false
  }
}

// ç­–ç•¥å·¥å‚
export function createDebounceByStrategy(strategyName, fn) {
  const strategy = debounceStrategies[strategyName] || debounceStrategies.SEARCH
  
  return useDebounceFn(fn, strategy.delay, {
    maxWait: strategy.maxWait
  })
}

// ä½¿ç”¨
const saveData = createDebounceByStrategy('AUTO_SAVE', async (data) => {
  await api.save(data)
})
```

## ğŸ“Š æ€§èƒ½ç›‘æ§ä¸è°ƒè¯•

### **é˜²æŠ–æ€§èƒ½ç›‘æ§**
```javascript
// debounceMonitor.js
export function monitorDebouncePerformance() {
  const metrics = {
    calls: 0,
    executions: 0,
    savedCalls: 0,
    averageDelay: 0
  }
  
  const originalSetTimeout = window.setTimeout
  const originalClearTimeout = window.clearTimeout
  
  const timers = new Map()
  
  // æ‹¦æˆª setTimeout
  window.setTimeout = function(callback, delay, ...args) {
    const id = originalSetTimeout.call(this, () => {
      metrics.executions++
      callback()
    }, delay, ...args)
    
    timers.set(id, {
      start: Date.now(),
      delay
    })
    
    return id
  }
  
  // æ‹¦æˆª clearTimeout
  window.clearTimeout = function(id) {
    const timer = timers.get(id)
    if (timer) {
      const actualDelay = Date.now() - timer.start
      if (actualDelay < timer.delay) {
        metrics.savedCalls++
      }
      timers.delete(id)
    }
    
    return originalClearTimeout.call(this, id)
  }
  
  // åˆ›å»ºå¸¦ç›‘æ§çš„é˜²æŠ–
  const createMonitoredDebounce = (fn, delay) => {
    let timer = null
    
    return (...args) => {
      metrics.calls++
      
      if (timer) {
        window.clearTimeout(timer)
      }
      
      timer = window.setTimeout(() => {
        fn(...args)
      }, delay)
    }
  }
  
  return {
    createMonitoredDebounce,
    getMetrics: () => ({
      ...metrics,
      efficiency: metrics.savedCalls / metrics.calls * 100
    })
  }
}
```

### **Vue DevTools æ’ä»¶**
```javascript
// vue-debounce-devtools.js
export const VueDebounceDevtools = {
  install(app, options = {}) {
    const debouncedFunctions = new Map()
    
    // åŒ…è£…æ‰€æœ‰ methods ä¸­çš„å‡½æ•°
    app.mixin({
      beforeCreate() {
        const methods = this.$options.methods
        if (methods) {
          Object.keys(methods).forEach(key => {
            const originalFn = methods[key]
            
            // æ£€æŸ¥æ˜¯å¦æœ‰ @debounce è£…é¥°å™¨
            const debounceMeta = originalFn.__debounce
            if (debounceMeta) {
              const { delay = 300 } = debounceMeta
              
              const debouncedFn = debounce(originalFn, delay)
              methods[key] = debouncedFn
              
              debouncedFunctions.set(debouncedFn, {
                component: this.$options.name || 'Anonymous',
                method: key,
                delay,
                calls: 0,
                executions: 0
              })
            }
          })
        }
      }
    })
    
    // æ·»åŠ åˆ° DevTools
    if (window.__VUE_DEVTOOLS_GLOBAL_HOOK__) {
      window.__VUE_DEVTOOLS_GLOBAL_HOOK__.on.debounce = debouncedFunctions
    }
  }
}

// è£…é¥°å™¨
export function Debounce(delay = 300) {
  return function(target, key, descriptor) {
    const original = descriptor.value
    descriptor.value = function(...args) {
      if (!this.__debounceTimer) {
        this.__debounceTimer = setTimeout(() => {
          original.apply(this, args)
          this.__debounceTimer = null
        }, delay)
      }
    }
    descriptor.value.__debounce = { delay }
    return descriptor
  }
}

// ä½¿ç”¨
import { Debounce } from './vue-debounce-devtools'

export default {
  methods: {
    @Debounce(500)
    handleSearch() {
      // é˜²æŠ–å¤„ç†
    }
  }
}
```

## ğŸ¯ æœ€ä½³å®è·µæ€»ç»“

### **é˜²æŠ–é…ç½®æ¨èå€¼**
```javascript
const DEBOUNCE_CONFIG = {
  SEARCH_INPUT: 300,      // æœç´¢æ¡†
  FORM_VALIDATION: 500,   // è¡¨å•éªŒè¯
  AUTO_SAVE: 1000,        // è‡ªåŠ¨ä¿å­˜
  WINDOW_RESIZE: 200,     // çª—å£è°ƒæ•´
  BUTTON_CLICK: 1000,     // æŒ‰é’®é˜²é‡
  SCROLL_EVENTS: 150,     // æ»šåŠ¨äº‹ä»¶
  MOUSE_MOVE: 100,        // é¼ æ ‡ç§»åŠ¨
  REAL_TIME_SAVE: 3000    // å®æ—¶ä¿å­˜ï¼ˆé•¿å»¶è¿Ÿï¼‰
}
```

### **ç»„ä»¶è®¾è®¡æ¨¡å¼**
```vue
<!-- DebounceInput.vue - å¯å¤ç”¨çš„é˜²æŠ–è¾“å…¥ç»„ä»¶ -->
<template>
  <input
    :value="modelValue"
    @input="handleInput"
    v-bind="$attrs"
  />
</template>

<script setup>
import { useDebounceFn } from '@vueuse/core'

const props = defineProps({
  modelValue: String,
  delay: {
    type: Number,
    default: 300
  },
  immediate: {
    type: Boolean,
    default: false
  }
})

const emit = defineEmits(['update:modelValue', 'change'])

// é˜²æŠ–å¤„ç†
const debouncedEmit = useDebounceFn((value) => {
  emit('update:modelValue', value)
  emit('change', value)
}, props.delay)

const handleInput = (event) => {
  const value = event.target.value
  
  if (props.immediate) {
    emit('update:modelValue', value)
  }
  
  debouncedEmit(value)
}
</script>
```

### **é”™è¯¯å¤„ç†ä¸è¾¹ç•Œæƒ…å†µ**
```javascript
// å¥å£®çš„é˜²æŠ–å®ç°
function robustDebounce(fn, delay, options = {}) {
  const {
    maxWait = null,
    leading = false,
    trailing = true
  } = options
  
  let timer = null
  let lastCallTime = 0
  let lastInvokeTime = 0
  let lastArgs = null
  let lastThis = null
  let maxTimer = null
  
  function invokeFunc(time) {
    const args = lastArgs
    const thisArg = lastThis
    
    lastArgs = lastThis = null
    lastInvokeTime = time
    
    try {
      return fn.apply(thisArg, args)
    } catch (error) {
      console.error('é˜²æŠ–å‡½æ•°æ‰§è¡Œé”™è¯¯:', error)
      // å¯ä»¥åœ¨è¿™é‡Œæ·»åŠ é”™è¯¯å¤„ç†é€»è¾‘
      if (options.onError) {
        options.onError(error)
      }
      throw error
    }
  }
  
  function shouldInvoke(time) {
    const timeSinceLastCall = time - lastCallTime
    const timeSinceLastInvoke = time - lastInvokeTime
    
    return (
      lastCallTime === 0 ||
      timeSinceLastCall >= delay ||
      (maxWait !== null && timeSinceLastInvoke >= maxWait)
    )
  }
  
  // ... å…¶ä½™å®ç°
}
```

## ğŸ“ˆ æ€§èƒ½å½±å“åˆ†æ

| åœºæ™¯                      | æ— é˜²æŠ–       | æœ‰é˜²æŠ–      | æå‡ |
| ------------------------- | ------------ | ----------- | ---- |
| **æœç´¢è¾“å…¥ï¼ˆ10ä¸ªå­—ç¬¦ï¼‰**  | 10æ¬¡APIè°ƒç”¨  | 1æ¬¡APIè°ƒç”¨  | 90%  |
| **çª—å£resizeï¼ˆè°ƒæ•´5ç§’ï¼‰** | 300+æ¬¡é‡æ’   | 10-20æ¬¡é‡æ’ | 95%  |
| **è¡¨å•å®æ—¶éªŒè¯**          | é¢‘ç¹éªŒè¯é˜»å¡ | å¹³æ»‘éªŒè¯    | 80%  |
| **æŒ‰é’®é‡å¤ç‚¹å‡»**          | å¤šæ¬¡æäº¤     | å•æ¬¡æäº¤    | 100% |
| **æ»šåŠ¨åŠ è½½**              | é¢‘ç¹è®¡ç®—     | èŠ‚æµè®¡ç®—    | 85%  |

## ğŸš€ Vue 3 é˜²æŠ–è¦ç‚¹æ€»ç»“

1. **ä¼˜å…ˆä½¿ç”¨ VueUse** - `useDebounceFn` æœ€æ–¹ä¾¿
2. **åˆç†è®¾ç½®å»¶è¿Ÿ** - 300ms é€‚ç”¨äºå¤šæ•°åœºæ™¯
3. **æ³¨æ„å†…å­˜æ³„æ¼** - ç»„ä»¶å¸è½½æ—¶æ¸…ç†å®šæ—¶å™¨
4. **åŒºåˆ†é˜²æŠ–å’ŒèŠ‚æµ** - é˜²æŠ–ï¼šæœ€åä¸€æ¬¡ï¼ŒèŠ‚æµï¼šå›ºå®šé¢‘ç‡
5. **ç»“åˆä¸šåŠ¡åœºæ™¯** - æœç´¢ã€éªŒè¯ã€ä¿å­˜ä½¿ç”¨ä¸åŒç­–ç•¥
6. **ç›‘æ§æ€§èƒ½** - ç¡®ä¿é˜²æŠ–çœŸæ­£æå‡ä½“éªŒ

**è®°ä½**ï¼šé˜²æŠ–çš„ç›®çš„æ˜¯**æå‡ç”¨æˆ·ä½“éªŒï¼Œå‡å°‘ä¸å¿…è¦çš„è®¡ç®—/è¯·æ±‚**ï¼Œä¸æ˜¯æ‰€æœ‰çš„è¾“å…¥éƒ½éœ€è¦é˜²æŠ–ã€‚å…³é”®äº¤äº’åº”è¯¥ä¿æŒå³æ—¶å“åº”ï¼