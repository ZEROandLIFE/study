# Vue 路由守卫详解

Vue 路由守卫（Navigation Guards）是 Vue Router 提供的一系列钩子函数，用于在路由导航过程中执行自定义逻辑。它们可以控制路由跳转、进行权限验证、添加加载状态等。

## 路由守卫的类型

Vue Router 提供了三种类型的路由守卫：

### 1. 全局守卫

对所有路由跳转生效的守卫：

#### `router.beforeEach`
```javascript
router.beforeEach((to, from, next) => {
  console.log('全局前置守卫')
  next() // 必须调用 next() 来解析钩子
})
```

#### `router.beforeResolve`
```javascript
router.beforeResolve((to, from, next) => {
  console.log('全局解析守卫')
  next()
})
```

#### `router.afterEach`
```javascript
router.afterEach((to, from) => {
  console.log('全局后置钩子')
  // 不需要 next()
})
```

### 2. 路由独享守卫

在路由配置中直接定义的守卫：

```javascript
const router = new VueRouter({
  routes: [
    {
      path: '/admin',
      component: Admin,
      beforeEnter: (to, from, next) => {
        console.log('路由独享守卫')
        next()
      }
    }
  ]
})
```

### 3. 组件内守卫

在组件内部定义的守卫：

#### `beforeRouteEnter`
```javascript
export default {
  beforeRouteEnter(to, from, next) {
    console.log('进入组件守卫')
    // 注意：此时组件实例还未创建，不能访问 this
    next(vm => {
      // 通过 vm 访问组件实例
    })
  }
}
```

#### `beforeRouteUpdate`
```javascript
export default {
  beforeRouteUpdate(to, from, next) {
    console.log('路由更新守卫')
    // 在当前路由改变，但是该组件被复用时调用
    next()
  }
}
```

#### `beforeRouteLeave`
```javascript
export default {
  beforeRouteLeave(to, from, next) {
    console.log('离开组件守卫')
    // 可以用来防止用户未保存就离开
    const answer = window.confirm('确定要离开吗？未保存的数据会丢失！')
    if (answer) {
      next()
    } else {
      next(false)
    }
  }
}
```

## 守卫参数说明

每个守卫函数接收三个参数：
- `to: Route`: 即将要进入的目标路由对象
- `from: Route`: 当前导航正要离开的路由
- `next: Function`: 一定要调用该方法来 resolve 这个钩子

`next` 函数的几种用法：
- `next()`: 进入管道中的下一个钩子
- `next(false)`: 中断当前导航
- `next('/')` 或 `next({ path: '/' })`: 跳转到其他地址
- `next(error)`: 导航会被终止且错误会被传递给 `router.onError()`

## 完整导航解析流程

1. 导航被触发
2. 调用失活的组件里的 `beforeRouteLeave` 守卫
3. 调用全局的 `beforeEach` 守卫
4. 在重用的组件里调用 `beforeRouteUpdate` 守卫
5. 调用路由配置里的 `beforeEnter` 守卫
6. 解析异步路由组件
7. 在被激活的组件里调用 `beforeRouteEnter`
8. 调用全局的 `beforeResolve` 守卫
9. 导航被确认
10. 调用全局的 `afterEach` 钩子
11. 触发 DOM 更新
12. 调用 `beforeRouteEnter` 守卫中传给 `next` 的回调函数，创建好的组件实例会作为回调函数的参数传入

## 实际应用示例

### 1. 权限验证

```javascript
router.beforeEach((to, from, next) => {
  const isAuthenticated = checkAuth() // 假设的认证检查函数
  
  if (to.matched.some(record => record.meta.requiresAuth)) {
    if (!isAuthenticated) {
      next({
        path: '/login',
        query: { redirect: to.fullPath }
      })
    } else {
      next()
    }
  } else {
    next()
  }
})
```
`to.matched.some(record => record.meta.requiresAuth)` 的作用是：
检查目标路由及其嵌套父路由中是否有任意一条配置了 meta.requiresAuth: true，确保需要认证的路由不会被未授权访问。

### 2. 页面标题更新

```javascript
router.afterEach((to, from) => {
  document.title = to.meta.title || '默认标题'
})
```

### 3. 数据预加载

```javascript
export default {
  beforeRouteEnter(to, from, next) {
    getPost(to.params.id, (err, post) => {
      next(vm => vm.setData(err, post))
    })
  },
  beforeRouteUpdate(to, from, next) {
    this.getPost(to.params.id, (err, post) => {
      this.setData(err, post)
      next()
    })
  },
  methods: {
    setData(err, post) {
      // 设置数据逻辑
    }
  }
}
```

## 注意事项

1. 确保调用 `next()` 方法，否则钩子不会被 resolved
2. 全局守卫按照注册顺序执行
3. 在组件内守卫中，`beforeRouteEnter` 是唯一不能访问 `this` 的守卫
4. 对于异步操作，确保在回调中调用 `next()`

路由守卫是 Vue Router 强大的功能之一，合理使用可以构建出体验良好、安全可靠的路由系统。