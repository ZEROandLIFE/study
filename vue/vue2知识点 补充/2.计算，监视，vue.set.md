# Vue2 计算属性、监视属性及 Vue.set 

## 计算属性 (Computed Properties)

### 基本概念
计算属性是基于它们的响应式依赖进行缓存的派生数据。只有在相关依赖发生改变时才会重新求值。

### 特点
1. **缓存机制**：只有依赖的响应式数据变化时才会重新计算
2. **声明式编程**：更声明式地描述数据关系
3. **同步操作**：计算属性默认是同步的

### 基本用法
```javascript
export default {
  data() {
    return {
      firstName: 'John',
      lastName: 'Doe'
    }
  },
  computed: {
    fullName: {
      // getter 函数
      get() {
        return this.firstName + ' ' + this.lastName
      },
      // setter 函数（可选）
      set(newValue) {
        const names = newValue.split(' ')
        this.firstName = names[0] || ''
        this.lastName = names[1] || ''
      }
    }
  }
}
```

### 简化写法（仅 getter）
```javascript
computed: {
  fullName() {
    return this.firstName + ' ' + this.lastName
  }
}
```

### 使用场景
- 模板中的复杂逻辑
- 需要缓存的计算结果
- 数据格式化（如日期格式化）
- 过滤/排序数据

### 与方法的区别
| 特性         | 计算属性                     | 方法                 |
| ------------ | ---------------------------- | -------------------- |
| 缓存         | 有缓存，依赖不变则不重新计算 | 每次调用都会重新执行 |
| 声明式       | 是                           | 否                   |
| 模板调用方式 | 直接使用属性名               | 需要加括号调用       |

## 监视属性 (Watchers)

### 基本概念
监视属性用于观察和响应 Vue 实例上的数据变动，适合执行异步或开销较大的操作。

### 三种写法

#### 1. 基本 watch
```javascript
export default {
  data() {
    return {
      question: '',
      answer: 'Questions usually contain a question mark. ;-)'
    }
  },
  watch: {
    question(newQuestion, oldQuestion) {
      if (newQuestion.includes('?')) {
        this.getAnswer()
      }
    }
  },
  methods: {
    getAnswer() {
      // 异步操作
    }
  }
}
```

#### 2. 对象形式（提供更多选项）
```javascript
watch: {
  question: {
    handler(newVal, oldVal) {
      // 处理逻辑
    },
    immediate: true, // 组件创建时立即执行一次
    deep: true       // 深度监视（对象内部变化）
  }
}
```

#### 3. $watch API
```javascript
export default {
  created() {
    this.$watch(
      'question',
      function(newVal, oldVal) {
        // 处理逻辑
      },
      {
        immediate: true,
        deep: true
      }
    )
  }
}
```

### 深度监视 (deep)
当需要监视对象内部属性的变化时使用：
```javascript
data() {
  return {
    user: {
      name: 'John',
      age: 30
    }
  }
},
watch: {
  user: {
    handler(newVal, oldVal) {
      console.log('用户信息变化了')
    },
    deep: true
  }
}
```

### 立即执行 (immediate)
组件创建时立即执行一次处理函数：
```javascript
watch: {
  question: {
    handler() {
      console.log('初始值:', this.question)
    },
    immediate: true
  }
}
```

### 使用场景
- 数据变化时执行异步操作
- 需要观察数据变化执行开销较大的操作
- 当需要在数据变化时执行一个操作，但这个操作的结果不直接需要显示在模板中

## Vue.set (全局方法)

### 基本概念
Vue.set 是 Vue 提供的全局方法，用于向响应式对象添加一个属性并确保这个新属性也是响应式的。

### 为什么需要 Vue.set
Vue 无法检测以下对象变化：
1. 在实例创建之后添加新的属性
2. 直接通过索引设置数组元素
3. 修改数组的长度

### 基本语法
```javascript
Vue.set(target, propertyName/index, value)
// 或简写为
this.$set(target, propertyName/index, value)
```

### 使用示例

#### 1. 向对象添加响应式属性
```javascript
export default {
  data() {
    return {
      user: {
        name: 'John'
      }
    }
  },
  methods: {
    addAge() {
      // 错误方式 - 新属性不是响应式的
      // this.user.age = 30
      
      // 正确方式
      this.$set(this.user, 'age', 30)
      // 或
      Vue.set(this.user, 'age', 30)
    }
  }
}
```

#### 2. 修改数组元素
```javascript
export default {
  data() {
    return {
      items: ['a', 'b', 'c']
    }
  },
  methods: {
    updateItem() {
      // 错误方式 - 不会触发视图更新
      // this.items[0] = 'x'
      
      // 正确方式
      this.$set(this.items, 0, 'x')
      
      // 或者使用数组的变异方法
      // this.items.splice(0, 1, 'x')
    }
  }
}
```

#### 3. 修改数组长度
```javascript
methods: {
  truncateArray() {
    // 错误方式 - 不会触发视图更新
    // this.items.length = 1
    
    // 正确方式
    this.items.splice(1) // 从索引1开始删除所有元素
  }
}
```

### 注意事项
1. 目标对象必须是响应式的（Vue 实例的 data 选项中的对象或通过 Vue.observable 创建的响应式对象）
2. 对于数组，Vue 包装了 7 个变异方法（push, pop, shift, unshift, splice, sort, reverse）来触发视图更新，优先使用这些方法
3. Vue.set 不能用于添加多个嵌套属性，如 `this.$set(this.obj, 'a.b', value)` 不会生效

## 总结

1. **计算属性 vs 监视属性**：
   - 优先使用计算属性，除非确实需要执行异步操作或开销较大的操作
   - 计算属性适合派生数据，监视属性适合执行副作用

2. **Vue.set 使用场景**：
   - 当需要向响应式对象添加新属性时
   - 当需要修改数组元素或长度且需要视图更新时

3. **性能优化**：
   - 计算属性有缓存，适合频繁使用的派生数据
   - 避免在计算属性中执行异步操作
   - 深度监视可能影响性能，谨慎使用

4. **代码组织**：
   - 将相关计算属性分组在一起
   - 复杂的计算逻辑可以拆分为多个计算属性
   - 监视属性可以按功能分组

