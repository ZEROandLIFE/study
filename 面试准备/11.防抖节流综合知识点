为什么多个防抖函数不会互相干扰？
答：因为每次调用 debounce 函数时：
都会创建一个新的函数执行上下文
在这个上下文中声明的 timer 变量是局部的
返回的内部函数通过闭包引用这个局部变量
每次调用返回不同的函数，每个函数闭包引用的是不同的 timer 变量
它们各自独立，互不干扰

闭包的核心特性：
函数可以记住并访问其词法作用域，即使函数在当前词法作用域之外执行
每次外部函数执行都会创建新的作用域和闭包
不同的闭包引用不同的变量，即使变量名相同

为什么防抖没有date来处理时间，节流需要？
// 防抖的逻辑：
// 条件：是否在 delay 时间内有新的触发？
// if (有新触发) 重置计时
// else 执行
// 节流的逻辑：
// 条件：距离上次执行是否超过 delay？
// if (now - lastTime >= delay) 执行

// 防抖适用场景：
// 1. 搜索框输入（等待用户停止输入）
// 2. 窗口 resize（等待调整结束）
// 3. 文本编辑器保存（等待用户暂停编辑）
// 节流适用场景：
// 1. 滚动加载更多（固定频率检查位置）
// 2. 游戏中的按键处理（固定帧率响应）
// 3. 鼠标移动跟随（平滑移动效果）