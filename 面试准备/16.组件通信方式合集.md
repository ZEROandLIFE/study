在 Vue 3 中，不同组件通信方式各有其适用场景和特点，以下是 **props、custom-event、mitt、v-model、$attrs、$refs/$parent、provide/inject、Pinia、slot** 的用法和区别：

### **1. Props（父 → 子）**
- **用途**：父组件向子组件传递数据。
- **特点**：
  - 单向数据流（父 → 子），子组件不可直接修改 props（需通过事件通知父组件修改）。
  - 适合传递静态或动态数据。
- **示例**：
  ```vue
  <!-- 父组件 -->
  <Child :message="parentMessage" />

  <!-- 子组件 -->
  <script setup>
  const props = defineProps({
    message: String
  });
  console.log(props.message); // 接收父组件数据
  </script>
  ```

### **2. Custom Event（子 → 父）**
- **用途**：子组件向父组件传递数据或通知事件。
- **特点**：
  - 通过 `$emit` 触发自定义事件，父组件监听事件。
  - 适合子组件主动通知父组件。
- **示例**：
  ```vue
  <!-- 子组件 -->
  <script setup>
  const emit = defineEmits(['update']);
  function handleClick() {
    emit('update', '子组件数据');
  }
  </script>
  <button @click="handleClick">触发事件</button>

  <!-- 父组件 -->
  <Child @update="handleUpdate" />
  ```

### **3. Mitt（全局事件总线）**
- **用途**：跨组件、跨层级通信（无直接父子关系）。
- **特点**：
  - 轻量级事件库，需手动安装（`npm install mitt`）。
  - 适合非父子组件或复杂层级通信。
- **示例**：
  ```javascript
  // eventBus.js
  import mitt from 'mitt';
  export const emitter = mitt();

  <!-- 组件A（发送事件） -->
  <script setup>
  import { emitter } from './eventBus';
  emitter.emit('event-name', { data: '123' });
  </script>

  <!-- 组件B（接收事件） -->
  <script setup>
  import { emitter } from './eventBus';
  import { onMounted, onUnmounted } from 'vue';
  onMounted(() => emitter.on('event-name', (data) => console.log(data)));
  onUnmounted(() => emitter.off('event-name')); // 避免内存泄漏
  </script>
  ```

### **4. V-model（父子双向绑定）**
- **用途**：实现父子组件的双向数据绑定（如表单输入）。
- **特点**：
  - 默认绑定 `modelValue` prop 和 `update:modelValue` 事件。
  - 支持多个 `v-model` 绑定。
- **示例**：
  ```vue
  <!-- 父组件 -->
  <Child v-model="parentValue" v-model:title="parentTitle" />

  <!-- 子组件 -->
  <script setup>
  const props = defineProps(['modelValue', 'title']);
  const emit = defineEmits(['update:modelValue', 'update:title']);
  </script>
  <input :value="modelValue" @input="emit('update:modelValue', $event.target.value)" />
  ```

### **5. $attrs（继承非 Prop属性）**
- **用途**：接收父组件传递的未在 `props` 中声明的属性。
- **特点**：
  - 包含父组件传递的所有非 prop 属性（如 `class`、`style`、自定义属性）。
  - 适合高阶组件或组件封装。
- **示例**：
  ```vue
  <!-- 父组件 -->
  <Child custom-attr="123" class="box" />

  <!-- 子组件 -->
  <script setup>
  const props = defineProps({ /* ... */ });
  const attrs = useAttrs(); // 获取所有非 prop 属性
  console.log(attrs.customAttr); // "123"
  </script>
  ```

### **6. $refs / $parent（直接访问组件/父组件）**
- **用途**：
  - `$refs`：父组件直接访问子组件的实例或 DOM 元素。
  - `$parent`：子组件直接访问父组件实例（不推荐，破坏封装性）。
- **特点**：
  - 慎用，可能导致组件耦合度高。
- **示例**：
  ```vue
  <!-- 父组件 -->
  <Child ref="childRef" />
  <script setup>
  import { ref, onMounted } from 'vue';
  const childRef = ref(null);
  onMounted(() => childRef.value.someMethod()); // 调用子组件方法
  </script>

  <!-- 子组件 -->
  <script setup>
  defineExpose({ someMethod: () => console.log('子组件方法') });
  </script>
  ```

### **7. Provide / Inject（跨层级依赖注入）**
- **用途**：祖先组件向深层子孙组件传递数据。
- **特点**：
  - 类似 React 的 Context，适合主题、用户信息等全局数据。
  - 默认非响应式，需配合 `ref`/`reactive` 实现响应式。
- **示例**：
  ```vue
  <!-- 祖先组件 -->
  <script setup>
  import { provide, ref } from 'vue';
  const theme = ref('dark');
  provide('theme', theme); // 提供响应式数据
  </script>

  <!-- 子孙组件 -->
  <script setup>
  import { inject } from 'vue';
  const theme = inject('theme'); // 注入数据
  </script>
  ```

### **8. Pinia（全局状态管理）**
- **用途**：管理应用全局状态（类似 Vuex，但更轻量）。
- **特点**：
  - 支持响应式、模块化、TypeScript。
  - 适合大型应用的全局状态共享。
- **示例**：
  ```javascript
  // store/counter.js
  import { defineStore } from 'pinia';
  export const useCounterStore = defineStore('counter', {
    state: () => ({ count: 0 }),
    actions: {
      increment() { this.count++; }
    }
  });

  <!-- 组件中使用 -->
  <script setup>
  import { useCounterStore } from './store/counter';
  const counterStore = useCounterStore();
  </script>
  <button @click="counterStore.increment">{{ counterStore.count }}</button>
  ```

### **9. Slot（内容分发）**
- **用途**：父组件向子组件传递模板片段。
- **特点**：
  - 支持默认插槽、具名插槽、作用域插槽。
  - 适合组件复用和布局封装。
- **示例**：
  ```vue
  <!-- 子组件 -->
  <slot name="header"></slot>
  <slot></slot> <!-- 默认插槽 -->

  <!-- 父组件 -->
  <Child>
    <template v-slot:header>
      <h1>标题</h1>
    </template>
    <p>默认内容</p>
  </Child>
  ```

### **对比总结**
| **方式**         | **方向**            | **适用场景**                | **响应式**                | **复杂度** |
| ---------------- | ------------------- | --------------------------- | ------------------------- | ---------- |
| Props            | 父 → 子             | 简单父子通信                | 是                        | 低         |
| Custom Event     | 子 → 父             | 子组件通知父组件            | 否                        | 低         |
| Mitt             | 任意组件            | 跨组件/跨层级（无直接关系） | 否                        | 中         |
| V-model          | 父子双向绑定        | 表单输入、双向数据同步      | 是                        | 中         |
| $attrs           | 父 → 子（非 prop）  | 继承未声明的属性            | 否                        | 低         |
| $refs / $parent  | 父 ↔ 子             | 直接访问组件实例（慎用）    | 否                        | 高         |
| Provide / Inject | 祖先 → 子孙         | 跨层级依赖注入（如主题）    | 是（需配合 ref/reactive） | 中         |
| Pinia            | 全局                | 大型应用的全局状态管理      | 是                        | 高         |
| Slot             | 父 → 子（模板片段） | 组件复用和布局封装          | 否                        | 中         |

### **推荐选择**
- **简单父子通信**：Props + Custom Event。
- **跨组件通信**：Mitt（轻量级）或 Pinia（全局状态）。
- **跨层级通信**：Provide / Inject（简单场景）或 Pinia（复杂场景）。
- **表单双向绑定**：V-model。
- **组件复用**：Slot。