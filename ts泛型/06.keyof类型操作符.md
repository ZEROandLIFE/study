`keyof` 是 TypeScript 中的一个**类型操作符**，它的核心作用是**提取一个类型的所有键（属性名），并返回一个联合类型**。它在类型安全、泛型编程和高级类型操作中非常有用。以下是它的主要用途和实际示例：

---

## **1. 类型安全的属性访问**
`keyof` 可以确保你只能访问对象的有效属性，避免拼写错误或访问不存在的属性。

### **示例**
```typescript
type Person = {
  name: string;
  age: number;
};

type PersonKeys = keyof Person; // 'name' | 'age'

function getProperty<T, K extends keyof T>(obj: T, key: K): T[K] {
  return obj[key]; // ✅ 类型安全：key 必须是 T 的有效属性
}

const person: Person = { name: "Alice", age: 25 };

getProperty(person, "name"); // ✅ 正确，返回 string
getProperty(person, "age");  // ✅ 正确，返回 number
// getProperty(person, "gender"); // ❌ 错误：'gender' 不是 Person 的键
```
- **作用**：`keyof` 确保 `getProperty` 的第二个参数只能是 `Person` 的有效属性（`'name'` 或 `'age'`），避免运行时错误。

---

## **2. 动态访问对象属性（泛型约束）**
结合泛型，`keyof` 可以让你编写**动态访问对象属性**的通用函数，同时保持类型安全。

### **示例**
```typescript
type Product = {
  id: number;
  price: number;
  name: string;
};

function updateProperty<T, K extends keyof T>(obj: T, key: K, value: T[K]): T {
  return { ...obj, [key]: value }; // ✅ 类型安全：value 必须匹配 key 的类型
}

const product: Product = { id: 1, price: 100, name: "Laptop" };

updateProperty(product, "price", 200); // ✅ 正确，price 是 number
// updateProperty(product, "price", "200"); // ❌ 错误：'200' 不是 number
// updateProperty(product, "description", "New"); // ❌ 错误：'description' 不是 Product 的键
```
- **作用**：`keyof` 约束 `K` 只能是 `T` 的有效属性，`value` 的类型必须匹配该属性的类型。

---

## **3. 映射类型（Map Types）**
`keyof` 可以用于**映射类型**，即基于现有类型生成新类型（如 `Partial<T>`、`Readonly<T>`）。

### **示例：实现 `Partial<T>`**
```typescript
type Partial<T> = {
  [K in keyof T]?: T[K]; // 所有属性变为可选
};

type Person = { name: string; age: number };
type PartialPerson = Partial<Person>; // { name?: string; age?: number }
```
- **作用**：`keyof T` 遍历 `T` 的所有键，生成一个新类型，其中每个属性都是可选的。

### **示例：实现 `Readonly<T>`**
```typescript
type Readonly<T> = {
  readonly [K in keyof T]: T[K]; // 所有属性变为只读
};

type Person = { name: string; age: number };
type ReadonlyPerson = Readonly<Person>; // { readonly name: string; readonly age: number }
```
- **作用**：`keyof T` 遍历 `T` 的所有键，生成一个新类型，其中每个属性都是只读的。

---

## **4. 索引签名（Index Signatures）的 `keyof`**
如果对象有**索引签名**（如 `[key: string]: any`），`keyof` 会返回 `string | number`（因为数字键会被自动转为字符串）。

### **示例**
```typescript
type Arrayish = {
  [n: number]: unknown; // 数字索引签名
};

type A = keyof Arrayish; // number

const arr: Arrayish = [1, 2, 3];
const index: A = 0; // ✅ 正确
// const wrongIndex: A = "foo"; // ❌ 错误：string 不能赋值给 number
```

### **示例（字符串索引签名）**
```typescript
type Mapish = {
  [k: string]: boolean; // 字符串索引签名
};

type M = keyof Mapish; // string | number

const map: Mapish = { a: true, b: false };
const key1: M = "a"; // ✅ 正确
const key2: M = 100; // ✅ 正确（100 会被转为 "100"）
// const key3: M = true; // ❌ 错误：boolean 不能赋值给 string | number
```
- **作用**：`keyof` 确保索引访问的类型安全，避免非法键。

---

## **5. 结合 `typeof` 获取动态类型**
`keyof` 可以和 `typeof` 结合使用，从**运行时对象**推导出**编译时类型**。

### **示例**
```typescript
const person = { name: "Alice", age: 25 };

type PersonKeys = keyof typeof person; // 'name' | 'age'

function getPersonProperty(key: PersonKeys) {
  return person[key]; // ✅ 类型安全
}

getPersonProperty("name"); // ✅ 正确，返回 string
getPersonProperty("age");  // ✅ 正确，返回 number
// getPersonProperty("gender"); // ❌ 错误：'gender' 不是 person 的键
```
- **作用**：`typeof person` 获取 `person` 的类型，`keyof` 提取其键，确保类型安全。

---

## **总结：`keyof` 的核心用途**
| 用途                           | 示例                        | 作用                       |
| ------------------------------ | --------------------------- | -------------------------- |
| **类型安全的属性访问**         | `keyof Person`              | 确保只能访问有效属性       |
| **动态属性访问（泛型约束）**   | `K extends keyof T`         | 约束泛型参数，避免非法访问 |
| **映射类型（Map Types）**      | `Partial<T>`、`Readonly<T>` | 基于现有类型生成新类型     |
| **索引签名的类型安全**         | `keyof Arrayish`            | 确保索引访问的类型正确     |
| **结合 `typeof` 获取动态类型** | `keyof typeof person`       | 从运行时对象推导编译时类型 |

### **为什么 `keyof` 重要？**
- **避免运行时错误**：确保代码只能访问对象的合法属性。  
- **提高代码可维护性**：减少拼写错误和非法访问。  
- **支持泛型编程**：让类型操作更加灵活和强大。  

